const map = Array.prototype.map;
const reduce = Array.prototype.reduce;
const find = (list, predicate) => {
    const len = list.length;
    for (let i = 0; i < len; i++) {
        if (predicate(list[i])) {
            return list[i];
        }
    }
    return undefined;
};
const identity = (x) => x;
/**
 * Converts tree to list.
 *
 * @param tree Array-like object representing tree.
 * @param getChildNodes Function to return child nodes.
 * @param convertNode Function to modify each item of result list.
 * @param generateId Function to generate unique ids for each item of result list.
 * @return Returns list of out nodes.
 */
export function flatten(tree, getChildNodes, convertNode = identity, generateId = () => undefined) {
    const stack = (tree && tree.length) ? [{ pointer: tree, offset: 0 }] : [];
    const flat = [];
    let current;
    while (stack.length) {
        current = stack.pop();
        while (current.offset < current.pointer.length) {
            const node = current.pointer[current.offset];
            const nodeId = generateId(node);
            const children = getChildNodes(node);
            flat.push(convertNode(node, current.node, nodeId, current.nodeId));
            current.offset += 1;
            if (children) {
                stack.push(current);
                current = {
                    pointer: children,
                    offset: 0,
                    node,
                    nodeId
                };
            }
        }
    }
    return flat;
}
export function unflatten(list, isChildNode, addChildNode, convertNode) {
    if (convertNode === undefined) {
        return reduce.call(list, (tree, node) => {
            const parentNode = find(list, parent => isChildNode(node, parent));
            if (parentNode === undefined) {
                tree.push(node);
            }
            else {
                addChildNode(node, parentNode);
            }
            return tree;
        }, []);
    }
    else {
        const mappedList = map.call(list, (node) => ({
            in: node,
            out: convertNode(node)
        }));
        return reduce.call(mappedList, (tree, node) => {
            const parentNode = find(mappedList, parent => isChildNode(node.in, parent.in));
            if (parentNode === undefined) {
                tree.push(node.out);
            }
            else {
                addChildNode(node.out, find(mappedList, treeNode => treeNode.in === parentNode.in).out);
            }
            return tree;
        }, []);
    }
}
//# sourceMappingURL=un-flatten-tree.js.map