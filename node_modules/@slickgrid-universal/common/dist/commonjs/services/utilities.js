"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uniqueObjectArray = exports.uniqueArray = exports.unsubscribeAll = exports.toSnakeCase = exports.getHtmlElementOffset = exports.findOrDefault = exports.toSentenceCase = exports.toKebabCase = exports.toCamelCase = exports.titleCase = exports.thousandSeparatorFormatted = exports.setDeepValue = exports.sanitizeTextByAvailableSanitizer = exports.sanitizeHtmlToText = exports.parseUtcDate = exports.parseBoolean = exports.objectWithoutKey = exports.mapOperatorByFieldType = exports.mapOperatorToShorthandDesignation = exports.mapOperatorType = exports.mapFlatpickrDateFormatWithFieldType = exports.mapMomentDateFormatWithFieldType = exports.getTranslationPrefix = exports.getDescendantProperty = exports.formatNumber = exports.destroyObjectDomElementProps = exports.decimalFormatted = exports.isNumber = exports.htmlEncodedStringWithPadding = exports.htmlEntityDecode = exports.htmlEncode = exports.findItemInTreeStructure = exports.findItemInHierarchicalStructure = exports.emptyObject = exports.emptyElement = exports.deepCopy = exports.flattenToParentChildArray = exports.addTreeLevelByMutation = exports.unflattenParentChildArrayToTree = exports.castObservableToPromise = exports.arrayRemoveItemByIndex = exports.addWhiteSpaces = exports.addToArrayWhenNotExists = void 0;
const un_flatten_tree_1 = require("un-flatten-tree");
const DOMPurify_ = require("dompurify");
const moment_ = require("moment-mini");
const DOMPurify = DOMPurify_; // patch to fix rollup to work
const moment = moment_['default'] || moment_; // patch to fix rollup "moment has no default export" issue, document here https://github.com/rollup/rollup/issues/670
const constants_1 = require("../constants");
const index_1 = require("../enums/index");
/**
 * Add an item to an array only when the item does not exists, when the item is an object we will be using their "id" to compare
 * @param inputArray
 * @param inputItem
 * @param itemIdPropName
 */
function addToArrayWhenNotExists(inputArray, inputItem, itemIdPropName = 'id') {
    let arrayRowIndex = -1;
    if (typeof inputItem === 'object' && itemIdPropName in inputItem) {
        arrayRowIndex = inputArray.findIndex((item) => item[itemIdPropName] === inputItem[itemIdPropName]);
    }
    else {
        arrayRowIndex = inputArray.findIndex((item) => item === inputItem);
    }
    if (arrayRowIndex < 0) {
        inputArray.push(inputItem);
    }
}
exports.addToArrayWhenNotExists = addToArrayWhenNotExists;
/**
 * Simple function to which will loop and create as demanded the number of white spaces,
 * this is used in the CSV export
 * @param {Number} nbSpaces - number of white spaces to create
 * @param {String} spaceChar - optionally provide character to use as a space (could be override to use &nbsp; in html)
 */
function addWhiteSpaces(nbSpaces, spaceChar = ' ') {
    let result = '';
    for (let i = 0; i < nbSpaces; i++) {
        result += spaceChar;
    }
    return result;
}
exports.addWhiteSpaces = addWhiteSpaces;
/**
 * Remove a column from the grid by it's index in the grid
 * @param array input
 * @param index
 */
function arrayRemoveItemByIndex(array, index) {
    return array.filter((_el, i) => index !== i);
}
exports.arrayRemoveItemByIndex = arrayRemoveItemByIndex;
/**
 * Try casting an input of type Promise | Observable into a Promise type.
 * @param object which could be of type Promise or Observable
 * @param fromServiceName string representing the caller service name and will be used if we throw a casting problem error
 */
function castObservableToPromise(rxjs, input, fromServiceName = '') {
    let promise = input;
    if (input instanceof Promise) {
        // if it's already a Promise then return it
        return input;
    }
    else if (rxjs.isObservable(input)) {
        promise = rxjs.firstValueFrom(input);
    }
    if (!(promise instanceof Promise)) {
        throw new Error(`Something went wrong, Slickgrid-Universal ${fromServiceName} is not able to convert the Observable into a Promise.`);
    }
    return promise;
}
exports.castObservableToPromise = castObservableToPromise;
/**
 * Convert a flat array (with "parentId" references) into a hierarchical (tree) dataset structure (where children are array(s) inside their parent objects)
 * @param flatArray input array (flat dataset)
 * @param options you can provide the following tree data options (which are all prop names, except 1 boolean flag, to use or else use their defaults):: collapsedPropName, childrenPropName, parentPropName, identifierPropName and levelPropName and initiallyCollapsed (boolean)
 * @return roots - hierarchical (tree) data view array
 */
function unflattenParentChildArrayToTree(flatArray, options) {
    var _a, _b, _c, _d, _e;
    const identifierPropName = (_a = options === null || options === void 0 ? void 0 : options.identifierPropName) !== null && _a !== void 0 ? _a : 'id';
    const childrenPropName = (_b = options === null || options === void 0 ? void 0 : options.childrenPropName) !== null && _b !== void 0 ? _b : constants_1.Constants.treeDataProperties.CHILDREN_PROP;
    const parentPropName = (_c = options === null || options === void 0 ? void 0 : options.parentPropName) !== null && _c !== void 0 ? _c : constants_1.Constants.treeDataProperties.PARENT_PROP;
    const levelPropName = (_d = options === null || options === void 0 ? void 0 : options.levelPropName) !== null && _d !== void 0 ? _d : constants_1.Constants.treeDataProperties.TREE_LEVEL_PROP;
    const collapsedPropName = (_e = options === null || options === void 0 ? void 0 : options.collapsedPropName) !== null && _e !== void 0 ? _e : constants_1.Constants.treeDataProperties.COLLAPSED_PROP;
    const inputArray = flatArray || [];
    const roots = []; // items without parent which at the root
    // make them accessible by guid on this map
    const all = {};
    inputArray.forEach((item) => all[item[identifierPropName]] = item);
    // connect childrens to its parent, and split roots apart
    Object.keys(all).forEach((id) => {
        var _a;
        const item = all[id];
        if (!(parentPropName in item) || item[parentPropName] === null || item[parentPropName] === undefined || item[parentPropName] === '') {
            roots.push(item);
        }
        else if (item[parentPropName] in all) {
            const p = all[item[parentPropName]];
            if (!(childrenPropName in p)) {
                p[childrenPropName] = [];
            }
            p[childrenPropName].push(item);
            if (p[collapsedPropName] === undefined) {
                p[collapsedPropName] = (_a = options === null || options === void 0 ? void 0 : options.initiallyCollapsed) !== null && _a !== void 0 ? _a : false;
            }
        }
    });
    // we need and want to the Tree Level,
    // we can do that after the tree is created and mutate the array by adding a __treeLevel property on each item
    // perhaps there might be a way to add this while creating the tree for now that is the easiest way I found
    addTreeLevelByMutation(roots, { childrenPropName, levelPropName }, 0);
    return roots;
}
exports.unflattenParentChildArrayToTree = unflattenParentChildArrayToTree;
/**
 * Mutate the original array and add a treeLevel (defaults to `__treeLevel`) property on each item.
 * @param {Array<Object>} treeArray - hierarchical tree array
 * @param {Object} options - options containing info like children & treeLevel property names
 * @param {Number} [treeLevel] - current tree level
 */
function addTreeLevelByMutation(treeArray, options, treeLevel = 0) {
    var _a;
    const childrenPropName = ((_a = options === null || options === void 0 ? void 0 : options.childrenPropName) !== null && _a !== void 0 ? _a : constants_1.Constants.treeDataProperties.CHILDREN_PROP);
    if (Array.isArray(treeArray)) {
        for (const item of treeArray) {
            if (item) {
                if (Array.isArray(item[childrenPropName]) && item[childrenPropName].length > 0) {
                    treeLevel++;
                    addTreeLevelByMutation(item[childrenPropName], options, treeLevel);
                    treeLevel--;
                }
                item[options.levelPropName] = treeLevel;
            }
        }
    }
}
exports.addTreeLevelByMutation = addTreeLevelByMutation;
/**
 * Convert a hierarchical (tree) array (with children) into a flat array structure array (where the children are pushed as next indexed item in the array)
 * @param {Array<Object>} treeArray - input hierarchical (tree) array
 * @param {Object} options - you can provide "childrenPropName" (defaults to "children")
 * @return {Array<Object>} output - Parent/Child array
 */
function flattenToParentChildArray(treeArray, options) {
    var _a, _b, _c, _d, _e;
    const identifierPropName = ((_a = options === null || options === void 0 ? void 0 : options.identifierPropName) !== null && _a !== void 0 ? _a : 'id');
    const childrenPropName = ((_b = options === null || options === void 0 ? void 0 : options.childrenPropName) !== null && _b !== void 0 ? _b : constants_1.Constants.treeDataProperties.CHILDREN_PROP);
    const hasChildrenPropName = ((_c = options === null || options === void 0 ? void 0 : options.hasChildrenPropName) !== null && _c !== void 0 ? _c : constants_1.Constants.treeDataProperties.HAS_CHILDREN_PROP);
    const parentPropName = ((_d = options === null || options === void 0 ? void 0 : options.parentPropName) !== null && _d !== void 0 ? _d : constants_1.Constants.treeDataProperties.PARENT_PROP);
    const levelPropName = (_e = options === null || options === void 0 ? void 0 : options.levelPropName) !== null && _e !== void 0 ? _e : constants_1.Constants.treeDataProperties.TREE_LEVEL_PROP;
    if (options === null || options === void 0 ? void 0 : options.shouldAddTreeLevelNumber) {
        addTreeLevelByMutation(treeArray, { childrenPropName, levelPropName });
    }
    const flat = un_flatten_tree_1.flatten(treeArray, (node) => node[childrenPropName], (node, parentNode) => {
        return {
            [identifierPropName]: node[identifierPropName],
            [parentPropName]: parentNode !== undefined ? parentNode[identifierPropName] : null,
            [hasChildrenPropName]: !!node[childrenPropName],
            ...objectWithoutKey(node, childrenPropName) // reuse the entire object except the children array property
        };
    });
    return flat;
}
exports.flattenToParentChildArray = flattenToParentChildArray;
/**
 * Create an immutable clone of an array or object
 * (c) 2019 Chris Ferdinandi, MIT License, https://gomakethings.com
 * @param  {Array|Object} objectOrArray - the array or object to copy
 * @return {Array|Object} - the clone of the array or object
 */
function deepCopy(objectOrArray) {
    /**
     * Create an immutable copy of an object
     * @return {Object}
     */
    const cloneObj = () => {
        // Create new object
        const clone = {};
        // Loop through each item in the original
        // Recursively copy it's value and add to the clone
        for (const key in objectOrArray) {
            if (Object.prototype.hasOwnProperty.call(objectOrArray, key)) {
                clone[key] = deepCopy(objectOrArray[key]);
            }
        }
        return clone;
    };
    /**
     * Create an immutable copy of an array
     * @return {Array}
     */
    const cloneArr = () => objectOrArray.map((item) => deepCopy(item));
    // -- init --//
    // Get object type
    const type = Object.prototype.toString.call(objectOrArray).slice(8, -1).toLowerCase();
    // If an object
    if (type === 'object') {
        return cloneObj();
    }
    // If an array
    if (type === 'array') {
        return cloneArr();
    }
    // Otherwise, return it as-is
    return objectOrArray;
}
exports.deepCopy = deepCopy;
/**
 * Empty a DOM element by removing all of its DOM element children leaving with an empty element (basically an empty shell)
 * @return {object} element - updated element
 */
function emptyElement(element) {
    if (element === null || element === void 0 ? void 0 : element.firstChild) {
        while (element.firstChild) {
            if (element.lastChild) {
                element.removeChild(element.lastChild);
            }
        }
    }
    return element;
}
exports.emptyElement = emptyElement;
/**
 * Empty an object properties by looping through them all and deleting them
 * @param obj - input object
 */
function emptyObject(obj) {
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            delete obj[key];
        }
    }
    obj = null;
    obj = {};
    return obj;
}
exports.emptyObject = emptyObject;
/**
 * @deprecated use `findItemInTreeStructure()` instead. Find an item from a hierarchical (tree) view structure (a parent that can have children array which themseleves can children and so on)
 * @param treeArray
 * @param predicate
 * @param childrenPropertyName
 */
function findItemInHierarchicalStructure(treeArray, predicate, childrenPropertyName) {
    return findItemInTreeStructure(treeArray, predicate, childrenPropertyName);
}
exports.findItemInHierarchicalStructure = findItemInHierarchicalStructure;
/**
 * Find an item from a tree (hierarchical) view structure (a parent that can have children array which themseleves can children and so on)
 * @param {Array<Object>} treeArray - hierarchical tree dataset
 * @param {Function} predicate - search predicate to find the item in the hierarchical tree structure
 * @param {String} childrenPropertyName - children property name to use in the tree (defaults to "children")
 */
function findItemInTreeStructure(treeArray, predicate, childrenPropertyName) {
    if (!childrenPropertyName) {
        throw new Error('findRecursive requires parameter "childrenPropertyName"');
    }
    const initialFind = treeArray.find(predicate);
    const elementsWithChildren = treeArray.filter((x) => childrenPropertyName in x && x[childrenPropertyName]);
    if (initialFind) {
        return initialFind;
    }
    else if (elementsWithChildren.length) {
        const childElements = [];
        elementsWithChildren.forEach((item) => {
            if (childrenPropertyName in item) {
                childElements.push(...item[childrenPropertyName]);
            }
        });
        return findItemInTreeStructure(childElements, predicate, childrenPropertyName);
    }
    return undefined;
}
exports.findItemInTreeStructure = findItemInTreeStructure;
/**
 * HTML encode using jQuery with a <div>
 * Create a in-memory div, set it's inner text(which jQuery automatically encodes)
 * then grab the encoded contents back out.  The div never exists on the page.
 */
function htmlEncode(inputValue) {
    const entityMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#39;'
    };
    return (inputValue || '').toString().replace(/[&<>"']/g, (s) => entityMap[s]);
}
exports.htmlEncode = htmlEncode;
/**
 * Decode text into html entity
 * @param string text: input text
 * @param string text: output text
 */
function htmlEntityDecode(input) {
    return input.replace(/&#(\d+);/g, (_match, dec) => {
        return String.fromCharCode(dec);
    });
}
exports.htmlEntityDecode = htmlEntityDecode;
/**
 * Encode string to html special char and add html space padding defined
 * @param {string} inputStr - input string
 * @param {number} paddingLength - padding to add
 */
function htmlEncodedStringWithPadding(inputStr, paddingLength) {
    const inputStrLn = inputStr.length;
    let outputStr = htmlEncode(inputStr);
    if (inputStrLn < paddingLength) {
        for (let i = inputStrLn; i < paddingLength; i++) {
            outputStr += `&nbsp;`;
        }
    }
    return outputStr;
}
exports.htmlEncodedStringWithPadding = htmlEncodedStringWithPadding;
/**
 * Check if input value is a number, by default it won't be a strict checking
 * but optionally we could check for strict equality, for example in strict "3" will return False but without strict it will return True
 * @param value - input value of any type
 * @param strict - when using strict it also check for strict equality, for example in strict "3" will return but without strict it will return true
 */
function isNumber(value, strict = false) {
    if (strict) {
        return (value === null || value === undefined || typeof value === 'string') ? false : !isNaN(value);
    }
    return (value === null || value === undefined || value === '') ? false : !isNaN(+value);
}
exports.isNumber = isNumber;
/**
 * Take a number (or a string) and display it as a formatted decimal string with defined minimum and maximum decimals
 * @param input
 * @param minDecimal
 * @param maxDecimal
 * @param decimalSeparator
 * @param thousandSeparator
 */
function decimalFormatted(input, minDecimal, maxDecimal, decimalSeparator = '.', thousandSeparator = '') {
    if (isNaN(+input)) {
        return input;
    }
    const minDec = (minDecimal === undefined) ? 2 : minDecimal;
    const maxDec = (maxDecimal === undefined) ? 2 : maxDecimal;
    let amount = String(Math.round(+input * Math.pow(10, maxDec)) / Math.pow(10, maxDec));
    if ((amount.indexOf('.') < 0) && (minDec > 0)) {
        amount += '.';
    }
    while ((amount.length - amount.indexOf('.')) <= minDec) {
        amount += '0';
    }
    const decimalSplit = amount.split('.');
    let integerNumber;
    let decimalNumber;
    // do we want to display our number with a custom separator in each thousand position
    if (thousandSeparator) {
        integerNumber = decimalSplit.length >= 1 ? thousandSeparatorFormatted(decimalSplit[0], thousandSeparator) : undefined;
    }
    else {
        integerNumber = decimalSplit.length >= 1 ? decimalSplit[0] : amount;
    }
    // when using a separator that is not a dot, replace it with the new separator
    if (decimalSplit.length > 1) {
        decimalNumber = decimalSplit[1];
    }
    let output = '';
    if (integerNumber !== undefined && decimalNumber !== undefined) {
        output = `${integerNumber}${decimalSeparator}${decimalNumber}`;
    }
    else if (integerNumber !== undefined && integerNumber !== null) {
        output = integerNumber;
    }
    return output;
}
exports.decimalFormatted = decimalFormatted;
/**
 * Loop through all properties of an object and nullify any properties that are instanceof HTMLElement,
 * if we detect an array then use recursion to go inside it and apply same logic
 * @param obj - object containing 1 or more properties with DOM Elements
 */
function destroyObjectDomElementProps(obj) {
    if (obj) {
        for (const key of Object.keys(obj)) {
            if (Array.isArray(obj[key])) {
                destroyObjectDomElementProps(obj[key]);
            }
            if (obj[key] instanceof HTMLElement) {
                obj[key] = null;
            }
        }
    }
}
exports.destroyObjectDomElementProps = destroyObjectDomElementProps;
/**
 * Format a number following options passed as arguments (decimals, separator, ...)
 * @param input
 * @param minDecimal
 * @param maxDecimal
 * @param displayNegativeNumberWithParentheses
 * @param symbolPrefix
 * @param symbolSuffix
 * @param decimalSeparator
 * @param thousandSeparator
 */
function formatNumber(input, minDecimal, maxDecimal, displayNegativeNumberWithParentheses, symbolPrefix = '', symbolSuffix = '', decimalSeparator = '.', thousandSeparator = '') {
    if (isNaN(+input)) {
        return input;
    }
    const calculatedValue = ((Math.round(parseFloat(input) * 1000000) / 1000000));
    if (calculatedValue < 0) {
        const absValue = Math.abs(calculatedValue);
        if (displayNegativeNumberWithParentheses) {
            if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
                return `(${symbolPrefix}${decimalFormatted(absValue, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)}${symbolSuffix})`;
            }
            const formattedValue = thousandSeparatorFormatted(`${absValue}`, thousandSeparator);
            return `(${symbolPrefix}${formattedValue}${symbolSuffix})`;
        }
        else {
            if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
                return `-${symbolPrefix}${decimalFormatted(absValue, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)}${symbolSuffix}`;
            }
            const formattedValue = thousandSeparatorFormatted(`${absValue}`, thousandSeparator);
            return `-${symbolPrefix}${formattedValue}${symbolSuffix}`;
        }
    }
    else {
        if (!isNaN(minDecimal) || !isNaN(maxDecimal)) {
            return `${symbolPrefix}${decimalFormatted(input, minDecimal, maxDecimal, decimalSeparator, thousandSeparator)}${symbolSuffix}`;
        }
        const formattedValue = thousandSeparatorFormatted(`${input}`, thousandSeparator);
        return `${symbolPrefix}${formattedValue}${symbolSuffix}`;
    }
}
exports.formatNumber = formatNumber;
/**
 * From a dot (.) notation path, find and return a property within an object given a path
 * @param object - object input
 * @param path - path of the complex object, string with dot (.) notation
 * @returns outputValue - the object property value found if any
 */
function getDescendantProperty(object, path) {
    if (!object || !path) {
        return object;
    }
    return path.split('.').reduce((obj, prop) => obj && obj[prop], object);
}
exports.getDescendantProperty = getDescendantProperty;
/** Get I18N Translation Prefix, defaults to an empty string */
function getTranslationPrefix(gridOptions) {
    if (gridOptions && gridOptions.translationNamespace) {
        return gridOptions.translationNamespace + (gridOptions.translationNamespaceSeparator || '');
    }
    return '';
}
exports.getTranslationPrefix = getTranslationPrefix;
/**
 * From a Date FieldType, return it's equivalent moment.js format
 * refer to moment.js for the format standard used: https://momentjs.com/docs/#/parsing/string-format/
 * @param fieldType
 */
function mapMomentDateFormatWithFieldType(fieldType) {
    let map;
    switch (fieldType) {
        case index_1.FieldType.dateTime:
        case index_1.FieldType.dateTimeIso:
            map = 'YYYY-MM-DD HH:mm:ss';
            break;
        case index_1.FieldType.dateTimeIsoAmPm:
            map = 'YYYY-MM-DD hh:mm:ss a';
            break;
        case index_1.FieldType.dateTimeIsoAM_PM:
            map = 'YYYY-MM-DD hh:mm:ss A';
            break;
        case index_1.FieldType.dateTimeShortIso:
            map = 'YYYY-MM-DD HH:mm';
            break;
        // all Euro Formats (date/month/year)
        case index_1.FieldType.dateEuro:
            map = 'DD/MM/YYYY';
            break;
        case index_1.FieldType.dateEuroShort:
            map = 'D/M/YY';
            break;
        case index_1.FieldType.dateTimeEuro:
            map = 'DD/MM/YYYY HH:mm:ss';
            break;
        case index_1.FieldType.dateTimeShortEuro:
            map = 'DD/MM/YYYY HH:mm';
            break;
        case index_1.FieldType.dateTimeEuroAmPm:
            map = 'DD/MM/YYYY hh:mm:ss a';
            break;
        case index_1.FieldType.dateTimeEuroAM_PM:
            map = 'DD/MM/YYYY hh:mm:ss A';
            break;
        case index_1.FieldType.dateTimeEuroShort:
            map = 'D/M/YY H:m:s';
            break;
        case index_1.FieldType.dateTimeEuroShortAmPm:
            map = 'D/M/YY h:m:s a';
            break;
        // all US Formats (month/date/year)
        case index_1.FieldType.dateUs:
            map = 'MM/DD/YYYY';
            break;
        case index_1.FieldType.dateUsShort:
            map = 'M/D/YY';
            break;
        case index_1.FieldType.dateTimeUs:
            map = 'MM/DD/YYYY HH:mm:ss';
            break;
        case index_1.FieldType.dateTimeUsAmPm:
            map = 'MM/DD/YYYY hh:mm:ss a';
            break;
        case index_1.FieldType.dateTimeUsAM_PM:
            map = 'MM/DD/YYYY hh:mm:ss A';
            break;
        case index_1.FieldType.dateTimeUsShort:
            map = 'M/D/YY H:m:s';
            break;
        case index_1.FieldType.dateTimeUsShortAmPm:
            map = 'M/D/YY h:m:s a';
            break;
        case index_1.FieldType.dateTimeShortUs:
            map = 'MM/DD/YYYY HH:mm';
            break;
        case index_1.FieldType.dateUtc:
            map = 'YYYY-MM-DDTHH:mm:ss.SSSZ';
            break;
        case index_1.FieldType.date:
        case index_1.FieldType.dateIso:
        default:
            map = 'YYYY-MM-DD';
            break;
    }
    return map;
}
exports.mapMomentDateFormatWithFieldType = mapMomentDateFormatWithFieldType;
/**
 * From a Date FieldType, return it's equivalent Flatpickr format
 * refer to Flatpickr for the format standard used: https://chmln.github.io/flatpickr/formatting/#date-formatting-tokens
 * also note that they seem very similar to PHP format (except for am/pm): http://php.net/manual/en/function.date.php
 * @param fieldType
 */
function mapFlatpickrDateFormatWithFieldType(fieldType) {
    /*
      d: Day of the month, 2 digits with leading zeros	01 to 31
      D: A textual representation of a day	Mon through Sun
      l: (lowercase 'L')	A full textual representation of the day of the week	Sunday through Saturday
      j: Day of the month without leading zeros	1 to 31
      J: Day of the month without leading zeros and ordinal suffix	1st, 2nd, to 31st
      w: Numeric representation of the day of the week	0 (for Sunday) through 6 (for Saturday)
      F: A full textual representation of a month	January through December
      m: Numeric representation of a month, with leading zero	01 through 12
      n: Numeric representation of a month, without leading zeros	1 through 12
      M: A short textual representation of a month	Jan through Dec
      U: The number of seconds since the Unix Epoch	1413704993
      y: A two digit representation of a year	99 or 03
      Y: A full numeric representation of a year, 4 digits	1999 or 2003
      H: Hours (24 hours)	00 to 23
      h: Hours	1 to 12
      i: Minutes	00 to 59
      S: Seconds, 2 digits	00 to 59
      s: Seconds	0, 1 to 59
      K: AM/PM	AM or PM
    */
    let map;
    switch (fieldType) {
        case index_1.FieldType.dateTime:
        case index_1.FieldType.dateTimeIso:
            map = 'Y-m-d H:i:S';
            break;
        case index_1.FieldType.dateTimeShortIso:
            map = 'Y-m-d H:i';
            break;
        case index_1.FieldType.dateTimeIsoAmPm:
        case index_1.FieldType.dateTimeIsoAM_PM:
            map = 'Y-m-d h:i:S K'; // there is no lowercase in Flatpickr :(
            break;
        // all Euro Formats (date/month/year)
        case index_1.FieldType.dateEuro:
            map = 'd/m/Y';
            break;
        case index_1.FieldType.dateEuroShort:
            map = 'd/m/y';
            break;
        case index_1.FieldType.dateTimeEuro:
            map = 'd/m/Y H:i:S';
            break;
        case index_1.FieldType.dateTimeShortEuro:
            map = 'd/m/y H:i';
            break;
        case index_1.FieldType.dateTimeEuroAmPm:
            map = 'd/m/Y h:i:S K'; // there is no lowercase in Flatpickr :(
            break;
        case index_1.FieldType.dateTimeEuroAM_PM:
            map = 'd/m/Y h:i:s K';
            break;
        case index_1.FieldType.dateTimeEuroShort:
            map = 'd/m/y H:i:s';
            break;
        case index_1.FieldType.dateTimeEuroShortAmPm:
            map = 'd/m/y h:i:s K'; // there is no lowercase in Flatpickr :(
            break;
        // all US Formats (month/date/year)
        case index_1.FieldType.dateUs:
            map = 'm/d/Y';
            break;
        case index_1.FieldType.dateUsShort:
            map = 'm/d/y';
            break;
        case index_1.FieldType.dateTimeUs:
            map = 'm/d/Y H:i:S';
            break;
        case index_1.FieldType.dateTimeShortUs:
            map = 'm/d/y H:i';
            break;
        case index_1.FieldType.dateTimeUsAmPm:
            map = 'm/d/Y h:i:S K'; // there is no lowercase in Flatpickr :(
            break;
        case index_1.FieldType.dateTimeUsAM_PM:
            map = 'm/d/Y h:i:s K';
            break;
        case index_1.FieldType.dateTimeUsShort:
            map = 'm/d/y H:i:s';
            break;
        case index_1.FieldType.dateTimeUsShortAmPm:
            map = 'm/d/y h:i:s K'; // there is no lowercase in Flatpickr :(
            break;
        case index_1.FieldType.dateUtc:
            map = 'Z';
            break;
        case index_1.FieldType.date:
        case index_1.FieldType.dateIso:
        default:
            map = 'Y-m-d';
            break;
    }
    return map;
}
exports.mapFlatpickrDateFormatWithFieldType = mapFlatpickrDateFormatWithFieldType;
/**
 * Mapper for query operators (ex.: <= is "le", > is "gt")
 * @param string operator
 * @returns string map
 */
function mapOperatorType(operator) {
    let map;
    switch (operator) {
        case '<':
        case 'LT':
            map = index_1.OperatorType.lessThan;
            break;
        case '<=':
        case 'LE':
            map = index_1.OperatorType.lessThanOrEqual;
            break;
        case '>':
        case 'GT':
            map = index_1.OperatorType.greaterThan;
            break;
        case '>=':
        case 'GE':
            map = index_1.OperatorType.greaterThanOrEqual;
            break;
        case '<>':
        case '!=':
        case 'NE':
            map = index_1.OperatorType.notEqual;
            break;
        case '*':
        case 'a*':
        case 'StartsWith':
            map = index_1.OperatorType.startsWith;
            break;
        case '*z':
        case 'EndsWith':
            map = index_1.OperatorType.endsWith;
            break;
        case '=':
        case '==':
        case 'EQ':
            map = index_1.OperatorType.equal;
            break;
        case 'IN':
            map = index_1.OperatorType.in;
            break;
        case 'NIN':
        case 'NOT_IN':
            map = index_1.OperatorType.notIn;
            break;
        case 'Not_Contains':
        case 'NOT_CONTAINS':
            map = index_1.OperatorType.notContains;
            break;
        case 'Contains':
        case 'CONTAINS':
        default:
            map = index_1.OperatorType.contains;
            break;
    }
    return map;
}
exports.mapOperatorType = mapOperatorType;
/**
 * Find equivalent short designation of an Operator Type or Operator String.
 * When using a Compound Filter, we use the short designation and so we need the mapped value.
 * For example OperatorType.startsWith short designation is "a*", while OperatorType.greaterThanOrEqual is ">="
 */
function mapOperatorToShorthandDesignation(operator) {
    let shortOperator = '';
    switch (operator) {
        case index_1.OperatorType.greaterThan:
        case '>':
            shortOperator = '>';
            break;
        case index_1.OperatorType.greaterThanOrEqual:
        case '>=':
            shortOperator = '>=';
            break;
        case index_1.OperatorType.lessThan:
        case '<':
            shortOperator = '<';
            break;
        case index_1.OperatorType.lessThanOrEqual:
        case '<=':
            shortOperator = '<=';
            break;
        case index_1.OperatorType.notEqual:
        case '<>':
            shortOperator = '<>';
            break;
        case index_1.OperatorType.equal:
        case '=':
        case '==':
        case 'EQ':
            shortOperator = '=';
            break;
        case index_1.OperatorType.startsWith:
        case 'a*':
        case '*':
            shortOperator = 'a*';
            break;
        case index_1.OperatorType.endsWith:
        case '*z':
            shortOperator = '*z';
            break;
        default:
            // any other operator will be considered as already a short expression, so we can return same input operator
            shortOperator = operator;
            break;
    }
    return shortOperator;
}
exports.mapOperatorToShorthandDesignation = mapOperatorToShorthandDesignation;
/**
 * Mapper for query operator by a Filter Type
 * For example a multiple-select typically uses 'IN' operator
 * @param operator
 * @returns string map
 */
function mapOperatorByFieldType(fieldType) {
    let map;
    switch (fieldType) {
        case index_1.FieldType.unknown:
        case index_1.FieldType.string:
        case index_1.FieldType.text:
        case index_1.FieldType.password:
        case index_1.FieldType.readonly:
            map = index_1.OperatorType.contains;
            break;
        case index_1.FieldType.float:
        case index_1.FieldType.number:
        case index_1.FieldType.date:
        case index_1.FieldType.dateIso:
        case index_1.FieldType.dateUtc:
        case index_1.FieldType.dateTime:
        case index_1.FieldType.dateTimeIso:
        case index_1.FieldType.dateTimeIsoAmPm:
        case index_1.FieldType.dateTimeIsoAM_PM:
        case index_1.FieldType.dateEuro:
        case index_1.FieldType.dateEuroShort:
        case index_1.FieldType.dateTimeEuro:
        case index_1.FieldType.dateTimeEuroAmPm:
        case index_1.FieldType.dateTimeEuroAM_PM:
        case index_1.FieldType.dateTimeEuroShort:
        case index_1.FieldType.dateTimeEuroShortAmPm:
        case index_1.FieldType.dateTimeEuroShortAM_PM:
        case index_1.FieldType.dateUs:
        case index_1.FieldType.dateUsShort:
        case index_1.FieldType.dateTimeUs:
        case index_1.FieldType.dateTimeUsAmPm:
        case index_1.FieldType.dateTimeUsAM_PM:
        case index_1.FieldType.dateTimeUsShort:
        case index_1.FieldType.dateTimeUsShortAmPm:
        case index_1.FieldType.dateTimeUsShortAM_PM:
        default:
            map = index_1.OperatorType.equal;
            break;
    }
    return map;
}
exports.mapOperatorByFieldType = mapOperatorByFieldType;
/**
 * Takes an object and allow to provide a property key to omit from the original object
 * @param {Object} obj - input object
 * @param {String} omitKey - object property key to omit
 * @returns {String} original object without the property that user wants to omit
 */
function objectWithoutKey(obj, omitKey) {
    return Object.keys(obj).reduce((result, objKey) => {
        if (objKey !== omitKey) {
            result[objKey] = obj[objKey];
        }
        return result;
    }, {});
}
exports.objectWithoutKey = objectWithoutKey;
/** Parse any input (bool, number, string) and return a boolean or False when not possible */
function parseBoolean(input) {
    return /(true|1)/i.test(input + '');
}
exports.parseBoolean = parseBoolean;
/**
 * Parse a date passed as a string (Date only, without time) and return a Date object (if valid)
 * @param inputDateString
 * @returns string date formatted
 */
function parseUtcDate(inputDateString, useUtc) {
    let date = '';
    if (typeof inputDateString === 'string' && /^[0-9\-\/]*$/.test(inputDateString)) {
        // get the UTC datetime with moment.js but we need to decode the value so that it's valid text
        const dateString = decodeURIComponent(inputDateString);
        const dateMoment = moment(new Date(dateString));
        if (dateMoment.isValid() && dateMoment.year().toString().length === 4) {
            date = (useUtc) ? dateMoment.utc().format() : dateMoment.format();
        }
    }
    return date;
}
exports.parseUtcDate = parseUtcDate;
/**
 * Sanitize, return only the text without HTML tags
 * @input htmlString
 * @return text
 */
function sanitizeHtmlToText(htmlString) {
    const temp = document.createElement('div');
    temp.innerHTML = htmlString;
    return temp.textContent || temp.innerText || '';
}
exports.sanitizeHtmlToText = sanitizeHtmlToText;
/**
 * Sanitize possible dirty html string (remove any potential XSS code like scripts and others), we will use 2 possible sanitizer
 * 1. optional sanitizer method defined in the grid options
 * 2. DOMPurify sanitizer (defaults)
 * @param gridOptions: grid options
 * @param dirtyHtml: dirty html string
 * @param domPurifyOptions: optional DOMPurify options when using that sanitizer
 */
function sanitizeTextByAvailableSanitizer(gridOptions, dirtyHtml, domPurifyOptions) {
    let sanitizedText = dirtyHtml;
    if (gridOptions && typeof gridOptions.sanitizer === 'function') {
        sanitizedText = gridOptions.sanitizer(dirtyHtml || '');
    }
    else if (typeof DOMPurify.sanitize === 'function') {
        sanitizedText = (DOMPurify.sanitize(dirtyHtml || '', domPurifyOptions || {}) || '').toString();
    }
    return sanitizedText;
}
exports.sanitizeTextByAvailableSanitizer = sanitizeTextByAvailableSanitizer;
/** Set the object value of deeper node from a given dot (.) notation path (e.g.: "user.firstName") */
function setDeepValue(obj, path, value) {
    if (typeof path === 'string') {
        path = path.split('.');
    }
    if (path.length > 1) {
        const e = path.shift();
        if (obj && e !== undefined) {
            setDeepValue(obj[e] = Object.prototype.toString.call(obj[e]) === '[object Object]' ? obj[e] : {}, path, value);
        }
    }
    else if (obj && path[0]) {
        obj[path[0]] = value;
    }
}
exports.setDeepValue = setDeepValue;
/**
 * Format a number or a string into a string that is separated every thousand,
 * the default separator is a comma but user can optionally pass a different one
 * @param inputValue
 * @param separator default to comma ","
 * @returns string
 */
function thousandSeparatorFormatted(inputValue, separator = ',') {
    if (inputValue !== null && inputValue !== undefined) {
        const stringValue = `${inputValue}`;
        const decimalSplit = stringValue.split('.');
        if (decimalSplit.length === 2) {
            return `${decimalSplit[0].replace(/\B(?=(\d{3})+(?!\d))/g, separator)}.${decimalSplit[1]}`;
        }
        return stringValue.replace(/\B(?=(\d{3})+(?!\d))/g, separator);
    }
    return inputValue;
}
exports.thousandSeparatorFormatted = thousandSeparatorFormatted;
/**
 * Title case (or capitalize) first char of a string, for example "hello world" will become "Hello world"
 * Change the string to be title case on the complete sentence (upper case first char of each word while changing everything else to lower case)
 * @param inputStr
 * @returns string
 */
function titleCase(inputStr, caseEveryWords = false) {
    if (typeof inputStr === 'string') {
        if (caseEveryWords) {
            return inputStr.replace(/\w\S*/g, (outputStr) => {
                return outputStr.charAt(0).toUpperCase() + outputStr.substr(1).toLowerCase();
            });
        }
        return inputStr.charAt(0).toUpperCase() + inputStr.slice(1);
    }
    return inputStr;
}
exports.titleCase = titleCase;
/**
 * Converts a string to camel case (camelCase), for example "hello-world" (or "hellow world") will become "helloWorld"
 * @param inputStr the string to convert
 * @return the string in camel case
 */
function toCamelCase(inputStr) {
    if (typeof inputStr === 'string') {
        return inputStr.replace(/(?:^\w|[A-Z]|\b\w|[\s+\-_\/])/g, (match, offset) => {
            // remove white space or hypens or underscores
            if (/[\s+\-_\/]/.test(match)) {
                return '';
            }
            return offset === 0 ? match.toLowerCase() : match.toUpperCase();
        });
    }
    return inputStr;
}
exports.toCamelCase = toCamelCase;
/**
 * Converts a string to kebab (hypen) case, for example "helloWorld" will become "hello-world"
 * @param str the string to convert
 * @return the string in kebab case
 */
function toKebabCase(inputStr) {
    if (typeof inputStr === 'string') {
        return toCamelCase(inputStr).replace(/([A-Z])/g, '-$1').toLowerCase();
    }
    return inputStr;
}
exports.toKebabCase = toKebabCase;
/**
 * Converts a camelCase or kebab-case string to a sentence case, for example "helloWorld" will become "Hello World" and "hello-world" will become "Hello world"
 * @param str the string to convert
 * @return the string in kebab case
 */
function toSentenceCase(inputStr) {
    if (typeof inputStr === 'string') {
        const result = inputStr.replace(/([A-Z])|(\-)/g, ' $1').replace(/\s+/g, ' ').trim();
        return result.charAt(0).toUpperCase() + result.slice(1);
    }
    return inputStr;
}
exports.toSentenceCase = toSentenceCase;
/**
 * Uses the logic function to find an item in an array or returns the default
 * value provided (empty object by default)
 * @param any[] array the array to filter
 * @param function logic the logic to find the item
 * @param any [defaultVal={}] the default value to return
 * @return object the found object or default value
 */
function findOrDefault(array, logic, defaultVal = {}) {
    if (Array.isArray(array)) {
        return array.find(logic) || defaultVal;
    }
    return array;
}
exports.findOrDefault = findOrDefault;
/** Get HTML Element position offset (without jQuery) */
function getHtmlElementOffset(element) {
    var _a;
    const rect = (_a = element === null || element === void 0 ? void 0 : element.getBoundingClientRect) === null || _a === void 0 ? void 0 : _a.call(element);
    let top = 0;
    let left = 0;
    if (rect && rect.top !== undefined && rect.left !== undefined) {
        top = rect.top + window.pageYOffset;
        left = rect.left + window.pageXOffset;
    }
    return { top, left };
}
exports.getHtmlElementOffset = getHtmlElementOffset;
/**
 * Converts a string from camelCase to snake_case (underscore) case
 * @param str the string to convert
 * @return the string in kebab case
 */
function toSnakeCase(inputStr) {
    if (typeof inputStr === 'string') {
        return toCamelCase(inputStr).replace(/([A-Z])/g, '_$1').toLowerCase();
    }
    return inputStr;
}
exports.toSnakeCase = toSnakeCase;
/**
 * Unsubscribe all Subscriptions
 * It will return an empty array if it all went well
 * @param subscriptions
 */
function unsubscribeAll(subscriptions) {
    if (Array.isArray(subscriptions)) {
        while (subscriptions.length > 0) {
            const subscription = subscriptions.pop();
            if (subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe) {
                subscription.unsubscribe();
            }
        }
    }
    return subscriptions;
}
exports.unsubscribeAll = unsubscribeAll;
/**
 * Takes an input array and makes sure the array has unique values by removing duplicates
 * @param array input with possible duplicates
 * @return array output without duplicates
 */
function uniqueArray(arr) {
    if (Array.isArray(arr) && arr.length > 0) {
        return arr.filter((item, index) => {
            return arr.indexOf(item) >= index;
        });
    }
    return arr;
}
exports.uniqueArray = uniqueArray;
/**
 * Takes an input array of objects and makes sure the array has unique object values by removing duplicates
 * it will loop through the array using a property name (or "id" when is not provided) to compare uniqueness
 * @param array input with possible duplicates
 * @param propertyName defaults to "id"
 * @return array output without duplicates
 */
function uniqueObjectArray(arr, propertyName = 'id') {
    if (Array.isArray(arr) && arr.length > 0) {
        const result = [];
        const map = new Map();
        for (const item of arr) {
            if (item && !map.has(item[propertyName])) {
                map.set(item[propertyName], true); // set any value to Map
                result.push({
                    id: item[propertyName],
                    name: item.name
                });
            }
        }
        return result;
    }
    return arr;
}
exports.uniqueObjectArray = uniqueObjectArray;
//# sourceMappingURL=utilities.js.map