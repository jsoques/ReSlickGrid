"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GridEventService = void 0;
class GridEventService {
    constructor() {
        this._eventHandler = new Slick.EventHandler();
    }
    get eventHandler() {
        return this._eventHandler;
    }
    dispose() {
        this._eventHandler.unsubscribeAll();
    }
    /* OnCellChange Event */
    bindOnBeforeEditCell(grid) {
        const dataView = (grid === null || grid === void 0 ? void 0 : grid.getData) && grid.getData();
        // subscribe to this Slickgrid event of onBeforeEditCell
        const onBeforeEditCellHandler = grid.onBeforeEditCell;
        this._eventHandler.subscribe(onBeforeEditCellHandler, (e, args) => {
            if (!e || !args || !grid || args.cell === undefined || !grid.getColumns || !grid.getDataItem) {
                return;
            }
            const column = grid.getColumns()[args.cell];
            // if the column definition has a onBeforeEditCell property (a callback function), then run it
            if (typeof column.onBeforeEditCell === 'function') {
                // add to the output gridOptions & dataView since we'll need them inside the AJAX column.onBeforeEditCell
                const returnedArgs = {
                    row: args.row,
                    cell: args.cell,
                    dataView,
                    grid,
                    columnDef: column,
                    dataContext: grid.getDataItem(args.row)
                };
                // finally call up the Slick.column.onBeforeEditCells.... function
                column.onBeforeEditCell(e, returnedArgs);
            }
        });
    }
    /* OnCellChange Event */
    bindOnCellChange(grid) {
        const dataView = (grid === null || grid === void 0 ? void 0 : grid.getData) && grid.getData();
        // subscribe to this Slickgrid event of onCellChange
        const onCellChangeHandler = grid.onCellChange;
        this._eventHandler.subscribe(onCellChangeHandler, (e, args) => {
            if (!e || !args || !grid || args.cell === undefined || !grid.getColumns || !grid.getDataItem) {
                return;
            }
            const column = grid.getColumns()[args.cell];
            // if the column definition has a onCellChange property (a callback function), then run it
            if (typeof column.onCellChange === 'function') {
                // add to the output gridOptions & dataView since we'll need them inside the AJAX column.onCellChange
                const returnedArgs = {
                    row: args.row,
                    cell: args.cell,
                    dataView,
                    grid,
                    columnDef: column,
                    dataContext: grid.getDataItem(args.row)
                };
                // finally call up the Slick.column.onCellChanges.... function
                column.onCellChange(e, returnedArgs);
            }
        });
    }
    /* OnClick Event */
    bindOnClick(grid) {
        const dataView = (grid === null || grid === void 0 ? void 0 : grid.getData) && grid.getData();
        const onClickHandler = grid.onClick;
        this._eventHandler.subscribe(onClickHandler, (e, args) => {
            if (!e || !args || !grid || args.cell === undefined || !grid.getColumns || !grid.getDataItem) {
                return;
            }
            const column = grid && grid.getColumns && grid.getColumns()[args.cell];
            const gridOptions = grid && grid.getOptions && grid.getOptions() || {};
            // only when the grid option "autoCommitEdit" is enabled, we will make the cell active (in focus) when clicked
            // setting the cell as active as a side effect and if "autoCommitEdit" is set to false then the Editors won't save correctly
            if (gridOptions.enableCellNavigation && (!gridOptions.editable || (gridOptions.editable && gridOptions.autoCommitEdit))) {
                grid.setActiveCell(args.row, args.cell, false, false, true);
            }
            // if the column definition has a onCellClick property (a callback function), then run it
            if (typeof column.onCellClick === 'function') {
                // add to the output gridOptions & dataView since we'll need them inside the AJAX column.onClick
                const returnedArgs = {
                    row: args.row,
                    cell: args.cell,
                    dataView,
                    grid,
                    columnDef: column,
                    dataContext: grid.getDataItem(args.row)
                };
                // finally call up the Slick.column.onCellClick.... function
                column.onCellClick(e, returnedArgs);
            }
        });
    }
}
exports.GridEventService = GridEventService;
//# sourceMappingURL=gridEvent.service.js.map