import { ToggleStateChangeType, ToggleStateChangeTypeString } from '../enums/index';
import { Column, ColumnSort, GridOption, OnClickEventArgs, SlickDataView, SlickEventData, SlickEventHandler, SlickGrid, TreeDataOption, TreeToggledItem, TreeToggleStateChange } from '../interfaces/index';
import { PubSubService } from './pubSub.service';
import { SharedService } from './shared.service';
import { SortService } from './sort.service';
export declare class TreeDataService {
    protected readonly pubSubService: PubSubService;
    protected readonly sharedService: SharedService;
    protected readonly sortService: SortService;
    protected _isLastFullToggleCollapsed: boolean;
    protected _lastToggleStateChange: Omit<TreeToggleStateChange, 'fromItemId'>;
    protected _currentToggledItems: TreeToggledItem[];
    protected _grid: SlickGrid;
    protected _eventHandler: SlickEventHandler;
    constructor(pubSubService: PubSubService, sharedService: SharedService, sortService: SortService);
    set currentToggledItems(newToggledItems: TreeToggledItem[]);
    get dataset(): any[];
    get datasetHierarchical(): any[] | undefined;
    /** Getter of SlickGrid DataView object */
    get dataView(): SlickDataView;
    /** Getter of the SlickGrid Event Handler */
    get eventHandler(): SlickEventHandler;
    get gridOptions(): GridOption;
    get treeDataOptions(): TreeDataOption;
    dispose(): void;
    init(grid: SlickGrid): void;
    /**
     * Apply different tree toggle state changes by providing an array of parentIds that are designated as collapsed (or not).
     * User will have to provide an array of `parentId` and `isCollapsed` boolean and the code will only apply the ones that are tagged as collapsed, everything else will be expanded
     * @param {Array<TreeToggledItem>} treeToggledItems - array of parentId which are tagged as changed
     * @param {ToggleStateChangeType} previousFullToggleType - optionally provide the previous full toggle type ('full-expand' or 'full-collapse')
     * @param {Boolean} shouldPreProcessFullToggle - should we pre-process a full toggle on all items? defaults to True
     * @param {Boolean} shouldTriggerEvent - should we trigger a toggled item event? defaults to False
     */
    applyToggledItemStateChanges(treeToggledItems: TreeToggledItem[], previousFullToggleType?: Exclude<ToggleStateChangeType, 'toggle-collapse' | 'toggle-expand'> | Exclude<ToggleStateChangeTypeString, 'toggle-collapse' | 'toggle-expand'>, shouldPreProcessFullToggle?: boolean, shouldTriggerEvent?: boolean): void;
    /**
     * Get the current toggle state that includes the type (toggle, full-expand, full-collapse) and toggled items (only applies when it's a parent toggle)
     * @returns {TreeToggleStateChange} treeDataToggledItems - items that were toggled (array of `parentId` and `isCollapsed` flag)
     */
    getCurrentToggleState(): Omit<TreeToggleStateChange, 'fromItemId'>;
    getInitialSort(columnDefinitions: Column[], gridOptions: GridOption): ColumnSort;
    /**
     * Get the full item count of the Tree.
     * When an optional tree level is provided, it will return the count for only that dedicated level (for example providing 0 would return the item count of all parent items)
     * @param {Number} [treeLevel] - optional tree level to get item count from
     * @returns
     */
    getItemCount(treeLevel?: number): number;
    /**
     * Get the current list of Tree Data item(s) that got toggled in the grid (basically the parents that the user clicked on the toggle icon to expand/collapse the child)
     * @returns {Array<TreeToggledItem>} treeDataToggledItems - items that were toggled (array of `parentId` and `isCollapsed` flag)
     */
    getToggledItems(): TreeToggledItem[];
    /** Find the associated property name from the Tree Data option when found or return a default property name that we defined internally */
    getTreeDataOptionPropName(optionName: keyof TreeDataOption): string;
    /**
     * Takes a flat dataset, converts it into a hierarchical dataset, sort it by recursion and finally return back the final and sorted flat array
     * @param {Array<Object>} flatDataset - parent/child flat dataset
     * @param {Object} gridOptions - grid options
     * @returns {Array<Object>} - tree dataset
     */
    convertFlatParentChildToTreeDatasetAndSort<P, T extends P & {
        [childrenPropName: string]: T[];
    }>(flatDataset: P[], columnDefinitions: Column[], gridOptions: GridOption): {
        hierarchical: (P & {
            [childrenPropName: string]: P[];
        })[];
        flat: Omit<P & {
            [childrenPropName: string]: P[];
        }, number | typeof Symbol.iterator | "toString" | "valueOf" | "toLocaleString" | "charAt" | "charCodeAt" | "concat" | "indexOf" | "lastIndexOf" | "localeCompare" | "match" | "replace" | "search" | "slice" | "split" | "substring" | "toLowerCase" | "toLocaleLowerCase" | "toUpperCase" | "toLocaleUpperCase" | "trim" | "length" | "substr" | "codePointAt" | "includes" | "endsWith" | "normalize" | "repeat" | "startsWith" | "anchor" | "big" | "blink" | "bold" | "fixed" | "fontcolor" | "fontsize" | "italics" | "link" | "small" | "strike" | "sub" | "sup" | "padStart" | "padEnd" | "trimLeft" | "trimRight" | "trimStart" | "trimEnd">[];
    };
    /**
     * Takes a flat dataset, converts it into a hierarchical dataset
     * @param {Array<Object>} flatDataset - parent/child flat dataset
     * @param {Object} gridOptions - grid options
     * @returns {Array<Object>} - tree dataset
     */
    convertFlatParentChildToTreeDataset<P, T extends P & {
        [childrenPropName: string]: P[];
    }>(flatDataset: P[], gridOptions: GridOption): T[];
    /**
     * Takes a hierarchical (tree) input array and sort it (if an `initialSort` exist, it will use that to sort)
     * @param {Array<Object>} hierarchicalDataset - inpu
     * @returns {Object} sort result object that includes both the flat & tree data arrays
     */
    sortHierarchicalDataset<T>(hierarchicalDataset: T[], inputColumnSorts?: ColumnSort | ColumnSort[]): {
        hierarchical: T[];
        flat: Omit<T, number | typeof Symbol.iterator | "toString" | "valueOf" | "toLocaleString" | "charAt" | "charCodeAt" | "concat" | "indexOf" | "lastIndexOf" | "localeCompare" | "match" | "replace" | "search" | "slice" | "split" | "substring" | "toLowerCase" | "toLocaleLowerCase" | "toUpperCase" | "toLocaleUpperCase" | "trim" | "length" | "substr" | "codePointAt" | "includes" | "endsWith" | "normalize" | "repeat" | "startsWith" | "anchor" | "big" | "blink" | "bold" | "fixed" | "fontcolor" | "fontsize" | "italics" | "link" | "small" | "strike" | "sub" | "sup" | "padStart" | "padEnd" | "trimLeft" | "trimRight" | "trimStart" | "trimEnd">[];
    };
    /**
     * Toggle the collapsed values of all parent items (the ones with children), we can optionally provide a flag to force a collapse or expand
     * @param {Boolean} collapsing - optionally force a collapse/expand (True => collapse all, False => expand all)
     * @param {Boolean} shouldTriggerEvent - defaults to true, should we trigger an event? For example, we could disable this to avoid a Grid State change event.
     * @returns {Promise<void>} - returns a void Promise, the reason we use a Promise is simply to make sure that when we add a spinner, it doesn't start/stop only at the end of the process
     */
    toggleTreeDataCollapse(collapsing: boolean, shouldTriggerEvent?: boolean): Promise<void>;
    protected handleOnCellClick(event: SlickEventData, args: OnClickEventArgs): void;
    protected updateToggledItem(item: any, isCollapsed: boolean): void;
}
