"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CellExternalCopyManagerExtension = void 0;
require("slickgrid/plugins/slick.cellexternalcopymanager");
const bindingEvent_service_1 = require("../services/bindingEvent.service");
const utilities_1 = require("../services/utilities");
class CellExternalCopyManagerExtension {
    constructor(extensionUtility, sharedService) {
        this.extensionUtility = extensionUtility;
        this.sharedService = sharedService;
        this._addon = null;
        this._addonOptions = null;
        this._eventHandler = new Slick.EventHandler();
        this._bindingEventService = new bindingEvent_service_1.BindingEventService();
    }
    get addonOptions() {
        return this._addonOptions;
    }
    get eventHandler() {
        return this._eventHandler;
    }
    get commandQueue() {
        return this._commandQueue;
    }
    get undoRedoBuffer() {
        return this._undoRedoBuffer;
    }
    /** Dispose of the 3rd party addon (plugin) */
    dispose() {
        var _a;
        // unsubscribe all SlickGrid events
        this._eventHandler.unsubscribeAll();
        if (this._addon && this._addon.destroy) {
            this._addon.destroy();
        }
        if ((_a = this._cellSelectionModel) === null || _a === void 0 ? void 0 : _a.destroy) {
            this._cellSelectionModel.destroy();
        }
        this.extensionUtility.nullifyFunctionNameStartingWithOn(this._addonOptions);
        this._addonOptions = null;
        this._bindingEventService.unbindAll();
    }
    /** Get the instance of the SlickGrid addon (control or plugin). */
    getAddonInstance() {
        return this._addon;
    }
    /** Register the 3rd party addon (plugin) */
    register() {
        if (this.sharedService && this.sharedService.slickGrid && this.sharedService.gridOptions) {
            this.createUndoRedoBuffer();
            this._bindingEventService.bind(document.body, 'keydown', this.handleKeyDown.bind(this));
            this._addonOptions = { ...this.getDefaultOptions(), ...this.sharedService.gridOptions.excelCopyBufferOptions };
            this._cellSelectionModel = new Slick.CellSelectionModel();
            this.sharedService.slickGrid.setSelectionModel(this._cellSelectionModel);
            this._addon = new Slick.CellExternalCopyManager(this._addonOptions);
            if (this._addon) {
                this.sharedService.slickGrid.registerPlugin(this._addon);
            }
            // hook to all possible events
            if (this.sharedService.slickGrid && this._addonOptions) {
                if (this._addon && this._addonOptions.onExtensionRegistered) {
                    this._addonOptions.onExtensionRegistered(this._addon);
                }
                const onCopyCellsHandler = this._addon.onCopyCells;
                this._eventHandler.subscribe(onCopyCellsHandler, (e, args) => {
                    if (this._addonOptions && typeof this._addonOptions.onCopyCells === 'function') {
                        this._addonOptions.onCopyCells(e, args);
                    }
                });
                const onCopyCancelledHandler = this._addon.onCopyCancelled;
                this._eventHandler.subscribe(onCopyCancelledHandler, (e, args) => {
                    if (this._addonOptions && typeof this._addonOptions.onCopyCancelled === 'function') {
                        this._addonOptions.onCopyCancelled(e, args);
                    }
                });
                const onPasteCellsHandler = this._addon.onPasteCells;
                this._eventHandler.subscribe(onPasteCellsHandler, (e, args) => {
                    if (this._addonOptions && typeof this._addonOptions.onPasteCells === 'function') {
                        this._addonOptions.onPasteCells(e, args);
                    }
                });
            }
            return this._addon;
        }
        return null;
    }
    /** Create an undo redo buffer used by the Excel like copy */
    createUndoRedoBuffer() {
        let commandCtr = 0;
        this._commandQueue = [];
        this._undoRedoBuffer = {
            queueAndExecuteCommand: (editCommand) => {
                this._commandQueue[commandCtr] = editCommand;
                commandCtr++;
                editCommand.execute();
            },
            undo: () => {
                if (commandCtr === 0) {
                    return;
                }
                commandCtr--;
                const command = this._commandQueue[commandCtr];
                if (command && Slick.GlobalEditorLock.cancelCurrentEdit()) {
                    command.undo();
                }
            },
            redo: () => {
                if (commandCtr >= this._commandQueue.length) {
                    return;
                }
                const command = this._commandQueue[commandCtr];
                commandCtr++;
                if (command && Slick.GlobalEditorLock.cancelCurrentEdit()) {
                    command.execute();
                }
            }
        };
    }
    /** @return default plugin (addon) options */
    getDefaultOptions() {
        let newRowIds = 0;
        return {
            clipboardCommandHandler: (editCommand) => {
                this._undoRedoBuffer.queueAndExecuteCommand.call(this._undoRedoBuffer, editCommand);
            },
            dataItemColumnValueExtractor: (item, columnDef) => {
                // when grid or cell is not editable, we will possibly evaluate the Formatter if it was passed
                // to decide if we evaluate the Formatter, we will use the same flag from Export which is "exportWithFormatter"
                if (!this.sharedService.gridOptions.editable || !columnDef.editor) {
                    const textExportOptions = { ...this.sharedService.gridOptions.exportOptions, ...this.sharedService.gridOptions.textExportOptions };
                    const isEvaluatingFormatter = (columnDef.exportWithFormatter !== undefined) ? columnDef.exportWithFormatter : (textExportOptions === null || textExportOptions === void 0 ? void 0 : textExportOptions.exportWithFormatter);
                    if (columnDef.formatter && isEvaluatingFormatter) {
                        const formattedOutput = columnDef.formatter(0, 0, item[columnDef.field], columnDef, item, this.sharedService.slickGrid);
                        if (columnDef.sanitizeDataExport || (textExportOptions === null || textExportOptions === void 0 ? void 0 : textExportOptions.sanitizeDataExport)) {
                            let outputString = formattedOutput;
                            if (formattedOutput && typeof formattedOutput === 'object' && formattedOutput.hasOwnProperty('text')) {
                                outputString = formattedOutput.text;
                            }
                            if (outputString === null) {
                                outputString = '';
                            }
                            return utilities_1.sanitizeHtmlToText(outputString);
                        }
                        return formattedOutput;
                    }
                }
                // else use the default "dataItemColumnValueExtractor" from the plugin itself
                // we can do that by setting back the getter with null
                return null;
            },
            readOnlyMode: false,
            includeHeaderWhenCopying: false,
            newRowCreator: (count) => {
                for (let i = 0; i < count; i++) {
                    this.sharedService.slickGrid.getData().addItem({ id: `newRow_${newRowIds++}` });
                }
            }
        };
    }
    /** Hook an undo shortcut key hook that will redo/undo the copy buffer using Ctrl+(Shift)+Z keyboard events */
    handleKeyDown(e) {
        const keyCode = e.keyCode || e.code;
        if (keyCode === 90 && (e.ctrlKey || e.metaKey)) {
            if (e.shiftKey) {
                this._undoRedoBuffer.redo(); // Ctrl + Shift + Z
            }
            else {
                this._undoRedoBuffer.undo(); // Ctrl + Z
            }
        }
    }
}
exports.CellExternalCopyManagerExtension = CellExternalCopyManagerExtension;
//# sourceMappingURL=cellExternalCopyManagerExtension.js.map