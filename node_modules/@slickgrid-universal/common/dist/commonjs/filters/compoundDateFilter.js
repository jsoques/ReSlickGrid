"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompoundDateFilter = void 0;
const flatpickr_ = require("flatpickr");
const flatpickr = (flatpickr_ && flatpickr_['default'] || flatpickr_); // patch for rollup
const index_1 = require("../enums/index");
const constants_1 = require("../constants");
const filterUtilities_1 = require("./filterUtilities");
const utilities_1 = require("../services/utilities");
const bindingEvent_service_1 = require("../services/bindingEvent.service");
class CompoundDateFilter {
    constructor(translaterService) {
        this.translaterService = translaterService;
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
        this.searchTerms = [];
        this._bindEventService = new bindingEvent_service_1.BindingEventService();
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get gridOptions() {
        return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
    }
    /** Getter for the Filter Operator */
    get columnFilter() {
        return this.columnDef && this.columnDef.filter || {};
    }
    /** Getter for the Current Dates selected */
    get currentDate() {
        return this._currentDate;
    }
    /** Getter to know what would be the default operator when none is specified */
    get defaultOperator() {
        return index_1.OperatorType.empty;
    }
    /** Getter for the Flatpickr Options */
    get flatpickrOptions() {
        return this._flatpickrOptions || {};
    }
    /** Getter for the single Locale texts provided by the user in main file or else use default English locales via the Constants */
    get locales() {
        return this.gridOptions.locales || constants_1.Constants.locales;
    }
    /** Getter for the Filter Operator */
    get operator() {
        return this._operator || this.columnFilter.operator || this.defaultOperator;
    }
    /** Setter for the Filter Operator */
    set operator(op) {
        this._operator = op;
    }
    /**
     * Initialize the Filter
     */
    init(args) {
        if (!args) {
            throw new Error('[Slickgrid-Universal] A filter must always have an "init()" with valid arguments.');
        }
        this.grid = args.grid;
        this.callback = args.callback;
        this.columnDef = args.columnDef;
        this.operator = args.operator || '';
        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
        // date input can only have 1 search term, so we will use the 1st array index if it exist
        const searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';
        // step 1, create the DOM Element of the filter which contain the compound Operator+Input
        // and initialize it if searchTerm is filled
        this._filterElm = this.createDomElement(searchTerm);
        // step 3, subscribe to the keyup event and run the callback when that happens
        // also add/remove "filled" class for styling purposes
        this._bindEventService.bind(this._filterDivInputElm, 'keyup', this.onTriggerEvent.bind(this));
        this._bindEventService.bind(this._selectOperatorElm, 'change', this.onTriggerEvent.bind(this));
    }
    /**
     * Clear the filter value
     */
    clear(shouldTriggerQuery = true) {
        if (this.flatInstance && this._selectOperatorElm) {
            this._clearFilterTriggered = true;
            this._shouldTriggerQuery = shouldTriggerQuery;
            this.searchTerms = [];
            this._selectOperatorElm.selectedIndex = 0;
            this.flatInstance.clear();
        }
    }
    /**
     * destroy the filter
     */
    destroy() {
        var _a, _b, _c, _d;
        this._bindEventService.unbindAll();
        if (this.flatInstance && typeof this.flatInstance.destroy === 'function') {
            this.flatInstance.destroy();
            if (this.flatInstance.element) {
                utilities_1.destroyObjectDomElementProps(this.flatInstance);
            }
        }
        (_b = (_a = this._filterElm) === null || _a === void 0 ? void 0 : _a.remove) === null || _b === void 0 ? void 0 : _b.call(_a);
        (_d = (_c = this._selectOperatorElm) === null || _c === void 0 ? void 0 : _c.remove) === null || _d === void 0 ? void 0 : _d.call(_c);
    }
    hide() {
        if (this.flatInstance && typeof this.flatInstance.close === 'function') {
            this.flatInstance.close();
        }
    }
    show() {
        if (this.flatInstance && typeof this.flatInstance.open === 'function') {
            this.flatInstance.open();
        }
    }
    /** Set value(s) in the DOM element, we can optionally pass an operator and/or trigger a change event */
    setValues(values, operator) {
        if (this.flatInstance && values) {
            const newValue = Array.isArray(values) ? values[0] : values;
            this._currentDate = newValue;
            this.flatInstance.setDate(newValue);
        }
        // set the operator, in the DOM as well, when defined
        this.operator = operator || this.defaultOperator;
        if (operator && this._selectOperatorElm) {
            const operatorShorthand = utilities_1.mapOperatorToShorthandDesignation(this.operator);
            this._selectOperatorElm.value = operatorShorthand;
        }
    }
    //
    // protected functions
    // ------------------
    buildDatePickerInput(searchTerm) {
        var _a, _b, _c, _d, _e, _f;
        const inputFormat = utilities_1.mapFlatpickrDateFormatWithFieldType(this.columnFilter.type || this.columnDef.type || index_1.FieldType.dateIso);
        const outputFormat = utilities_1.mapFlatpickrDateFormatWithFieldType(this.columnDef.outputType || this.columnFilter.type || this.columnDef.type || index_1.FieldType.dateUtc);
        const userFilterOptions = (this.columnFilter && this.columnFilter.filterOptions || {});
        // get current locale, if user defined a custom locale just use or get it the Translate Service if it exist else just use English
        let currentLocale = ((_a = userFilterOptions === null || userFilterOptions === void 0 ? void 0 : userFilterOptions.locale) !== null && _a !== void 0 ? _a : (_c = (_b = this.translaterService) === null || _b === void 0 ? void 0 : _b.getCurrentLanguage) === null || _c === void 0 ? void 0 : _c.call(_b)) || this.gridOptions.locale || 'en';
        if ((currentLocale === null || currentLocale === void 0 ? void 0 : currentLocale.length) > 2) {
            currentLocale = currentLocale.substring(0, 2);
        }
        // if we are preloading searchTerms, we'll keep them for reference
        if (searchTerm) {
            this._currentDate = searchTerm;
        }
        const pickerOptions = {
            defaultDate: searchTerm || '',
            altInput: true,
            altFormat: outputFormat,
            dateFormat: inputFormat,
            wrap: true,
            closeOnSelect: true,
            locale: currentLocale,
            onChange: (selectedDates, dateStr) => {
                this._currentValue = dateStr;
                this._currentDate = Array.isArray(selectedDates) && selectedDates[0] || undefined;
                // when using the time picker, we can simulate a keyup event to avoid multiple backend request
                // since backend request are only executed after user start typing, changing the time should be treated the same way
                let customEvent;
                if (pickerOptions.enableTime) {
                    customEvent = new CustomEvent('keyup');
                }
                this.onTriggerEvent(customEvent);
            },
            errorHandler: (error) => {
                if (error.toString().includes('invalid locale')) {
                    console.warn(`[Slickgrid-Universal] Flatpickr missing locale imports (${currentLocale}), will revert to English as the default locale.
          See Flatpickr Localization for more info, for example if we want to use French, then we can import it with:  import 'flatpickr/dist/l10n/fr';`);
                }
            }
        };
        // add the time picker when format is UTC (Z) or has the 'h' (meaning hours)
        if (outputFormat && (outputFormat === 'Z' || outputFormat.toLowerCase().includes('h'))) {
            pickerOptions.enableTime = true;
        }
        // merge options with optional user's custom options
        this._flatpickrOptions = { ...pickerOptions, ...userFilterOptions };
        // create the DOM element & add an ID and filter class
        let placeholder = (_e = (_d = this.gridOptions) === null || _d === void 0 ? void 0 : _d.defaultFilterPlaceholder) !== null && _e !== void 0 ? _e : '';
        if ((_f = this.columnFilter) === null || _f === void 0 ? void 0 : _f.placeholder) {
            placeholder = this.columnFilter.placeholder;
        }
        const filterDivInputElm = document.createElement('div');
        filterDivInputElm.className = 'flatpickr';
        const inputElm = document.createElement('input');
        inputElm.type = 'text';
        inputElm.className = 'form-control';
        inputElm.dataset.input = '';
        inputElm.placeholder = placeholder;
        filterDivInputElm.appendChild(inputElm);
        this.flatInstance = flatpickr(filterDivInputElm, this._flatpickrOptions);
        return filterDivInputElm;
    }
    /** Get the available operator option values to populate the operator select dropdown list */
    getOperatorOptionValues() {
        var _a;
        if ((_a = this.columnFilter) === null || _a === void 0 ? void 0 : _a.compoundOperatorList) {
            return this.columnFilter.compoundOperatorList;
        }
        else {
            return [
                { operator: '', description: '' },
                { operator: '=', description: this.getOutputText('EQUAL_TO', 'TEXT_EQUAL_TO', 'Equal to') },
                { operator: '<', description: this.getOutputText('LESS_THAN', 'TEXT_LESS_THAN', 'Less than') },
                { operator: '<=', description: this.getOutputText('LESS_THAN_OR_EQUAL_TO', 'TEXT_LESS_THAN_OR_EQUAL_TO', 'Less than or equal to') },
                { operator: '>', description: this.getOutputText('GREATER_THAN', 'TEXT_GREATER_THAN', 'Greater than') },
                { operator: '>=', description: this.getOutputText('GREATER_THAN_OR_EQUAL_TO', 'TEXT_GREATER_THAN_OR_EQUAL_TO', 'Greater than or equal to') },
                { operator: '<>', description: this.getOutputText('NOT_EQUAL_TO', 'TEXT_NOT_EQUAL_TO', 'Not equal to') }
            ];
        }
    }
    /** Get Locale, Translated or a Default Text if first two aren't detected */
    getOutputText(translationKey, localeText, defaultText) {
        var _a, _b, _c, _d;
        if (((_a = this.gridOptions) === null || _a === void 0 ? void 0 : _a.enableTranslate) && ((_b = this.translaterService) === null || _b === void 0 ? void 0 : _b.translate)) {
            const translationPrefix = utilities_1.getTranslationPrefix(this.gridOptions);
            return this.translaterService.translate(`${translationPrefix}${translationKey}`);
        }
        return (_d = (_c = this.locales) === null || _c === void 0 ? void 0 : _c[localeText]) !== null && _d !== void 0 ? _d : defaultText;
    }
    /**
     * Create the DOM element
     */
    createDomElement(searchTerm) {
        var _a, _b;
        const columnId = (_b = (_a = this.columnDef) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : '';
        const headerElm = this.grid.getHeaderRowColumn(columnId);
        utilities_1.emptyElement(headerElm);
        // create the DOM Select dropdown for the Operator
        this._selectOperatorElm = filterUtilities_1.buildSelectOperator(this.getOperatorOptionValues());
        this._filterDivInputElm = this.buildDatePickerInput(searchTerm);
        const filterContainerElm = document.createElement('div');
        filterContainerElm.className = `form-group search-filter filter-${columnId}`;
        const containerInputGroupElm = document.createElement('div');
        containerInputGroupElm.className = 'input-group flatpickr';
        const operatorInputGroupAddonElm = document.createElement('div');
        operatorInputGroupAddonElm.className = 'input-group-addon input-group-prepend operator';
        /* the DOM element final structure will be
          <div class="input-group">
            <div class="input-group-addon input-group-prepend operator">
              <select class="form-control"></select>
            </div>
            <div class="flatpickr">
              <input type="text" class="form-control" data-input>
            </div>
          </div>
        */
        operatorInputGroupAddonElm.appendChild(this._selectOperatorElm);
        containerInputGroupElm.appendChild(operatorInputGroupAddonElm);
        containerInputGroupElm.appendChild(this._filterDivInputElm);
        // create the DOM element & add an ID and filter class
        filterContainerElm.appendChild(containerInputGroupElm);
        this._filterDivInputElm.dataset.columnid = `${columnId}`;
        if (this.operator) {
            const operatorShorthand = utilities_1.mapOperatorToShorthandDesignation(this.operator);
            this._selectOperatorElm.value = operatorShorthand;
        }
        // if there's a search term, we will add the "filled" class for styling purposes
        if (searchTerm && searchTerm !== '') {
            this._filterDivInputElm.classList.add('filled');
            this._currentDate = searchTerm;
            this._currentValue = searchTerm;
        }
        // append the new DOM element to the header row
        if (filterContainerElm) {
            headerElm.appendChild(filterContainerElm);
        }
        return filterContainerElm;
    }
    onTriggerEvent(e) {
        if (this._clearFilterTriggered) {
            this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });
            this._filterElm.classList.remove('filled');
        }
        else {
            const selectedOperator = this._selectOperatorElm.value;
            (this._currentValue) ? this._filterElm.classList.add('filled') : this._filterElm.classList.remove('filled');
            this.callback(e, { columnDef: this.columnDef, searchTerms: (this._currentValue ? [this._currentValue] : null), operator: selectedOperator || '', shouldTriggerQuery: this._shouldTriggerQuery });
        }
        // reset both flags for next use
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
    }
}
exports.CompoundDateFilter = CompoundDateFilter;
//# sourceMappingURL=compoundDateFilter.js.map