"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCollectionAsyncSubject = exports.renderCollectionOptionsAsync = exports.renderDomElementFromCollectionAsync = exports.buildSelectOperator = void 0;
const utilities_1 = require("../services/utilities");
/**
 * Create and return a select dropdown HTML element with a list of Operators with descriptions
 * @param {Array<Object>} optionValues - list of operators and their descriptions
 * @returns {Object} selectElm - Select Dropdown HTML Element
 */
function buildSelectOperator(optionValues) {
    const selectElm = document.createElement('select');
    selectElm.className = 'form-control';
    for (const option of optionValues) {
        const selectOption = document.createElement('option');
        selectOption.value = option.operator;
        selectOption.innerHTML = `${utilities_1.htmlEncodedStringWithPadding(option.operator, 3)}${option.description}`;
        selectElm.appendChild(selectOption);
    }
    return selectElm;
}
exports.buildSelectOperator = buildSelectOperator;
/**
 * When user use a CollectionAsync we will use the returned collection to render the filter DOM element
 * and reinitialize filter collection with this new collection
 */
function renderDomElementFromCollectionAsync(collection, columnDef, renderDomElementCallback) {
    var _a, _b;
    const columnFilter = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.filter) !== null && _a !== void 0 ? _a : {};
    const collectionOptions = (_b = columnFilter === null || columnFilter === void 0 ? void 0 : columnFilter.collectionOptions) !== null && _b !== void 0 ? _b : {};
    if (collectionOptions && collectionOptions.collectionInsideObjectProperty) {
        const collectionInsideObjectProperty = collectionOptions.collectionInsideObjectProperty;
        collection = utilities_1.getDescendantProperty(collection, collectionInsideObjectProperty);
    }
    if (!Array.isArray(collection)) {
        throw new Error(`Something went wrong while trying to pull the collection from the "collectionAsync" call in the Filter, the collection is not a valid array.`);
    }
    // copy over the array received from the async call to the "collection" as the new collection to use
    // this has to be BEFORE the `collectionObserver().subscribe` to avoid going into an infinite loop
    columnFilter.collection = collection;
    // recreate Multiple Select after getting async collection
    renderDomElementCallback(collection);
}
exports.renderDomElementFromCollectionAsync = renderDomElementFromCollectionAsync;
async function renderCollectionOptionsAsync(collectionAsync, columnDef, renderDomElementCallback, rxjs, subscriptions) {
    var _a, _b, _c;
    const columnFilter = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.filter) !== null && _a !== void 0 ? _a : {};
    const collectionOptions = (_b = columnFilter === null || columnFilter === void 0 ? void 0 : columnFilter.collectionOptions) !== null && _b !== void 0 ? _b : {};
    let awaitedCollection = null;
    if (collectionAsync) {
        const isObservable = (_c = rxjs === null || rxjs === void 0 ? void 0 : rxjs.isObservable(collectionAsync)) !== null && _c !== void 0 ? _c : false;
        if (isObservable && rxjs) {
            awaitedCollection = await utilities_1.castObservableToPromise(rxjs, collectionAsync);
        }
        // wait for the "collectionAsync", once resolved we will save it into the "collection"
        const response = await collectionAsync;
        if (Array.isArray(response)) {
            awaitedCollection = response; // from Promise
        }
        else if (response instanceof Response && typeof response['json'] === 'function') {
            awaitedCollection = await response['json'](); // from Fetch
        }
        else if (response && response['content']) {
            awaitedCollection = response['content']; // from http-client
        }
        if (!Array.isArray(awaitedCollection) && (collectionOptions === null || collectionOptions === void 0 ? void 0 : collectionOptions.collectionInsideObjectProperty)) {
            const collection = awaitedCollection || response;
            const collectionInsideObjectProperty = collectionOptions.collectionInsideObjectProperty;
            awaitedCollection = utilities_1.getDescendantProperty(collection, collectionInsideObjectProperty || '');
        }
        if (!Array.isArray(awaitedCollection)) {
            throw new Error('Something went wrong while trying to pull the collection from the "collectionAsync" call in the Filter, the collection is not a valid array.');
        }
        // copy over the array received from the async call to the "collection" as the new collection to use
        // this has to be BEFORE the `collectionObserver().subscribe` to avoid going into an infinite loop
        columnFilter.collection = awaitedCollection;
        // recreate Multiple Select after getting async collection
        renderDomElementCallback(awaitedCollection);
        // because we accept Promises & HttpClient Observable only execute once
        // we will re-create an RxJs Subject which will replace the "collectionAsync" which got executed once anyway
        // doing this provide the user a way to call a "collectionAsync.next()"
        if (isObservable) {
            createCollectionAsyncSubject(columnDef, renderDomElementCallback, rxjs, subscriptions);
        }
    }
    return awaitedCollection;
}
exports.renderCollectionOptionsAsync = renderCollectionOptionsAsync;
/** Create or recreate an Observable Subject and reassign it to the "collectionAsync" object so user can call a "collectionAsync.next()" on it */
function createCollectionAsyncSubject(columnDef, renderDomElementCallback, rxjs, subscriptions) {
    var _a;
    const columnFilter = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.filter) !== null && _a !== void 0 ? _a : {};
    const newCollectionAsync = rxjs === null || rxjs === void 0 ? void 0 : rxjs.createSubject();
    columnFilter.collectionAsync = newCollectionAsync;
    if (subscriptions && newCollectionAsync) {
        subscriptions.push(newCollectionAsync.subscribe(collection => renderDomElementFromCollectionAsync(collection, columnDef, renderDomElementCallback)));
    }
}
exports.createCollectionAsyncSubject = createCollectionAsyncSubject;
//# sourceMappingURL=filterUtilities.js.map