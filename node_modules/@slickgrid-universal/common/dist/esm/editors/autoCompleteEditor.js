import 'jquery-ui/ui/widgets/autocomplete';
import { FieldType, KeyCode, } from '../enums/index';
import { textValidator } from '../editorValidators/textValidator';
import { findOrDefault, getDescendantProperty, sanitizeTextByAvailableSanitizer, setDeepValue, toKebabCase } from '../services/utilities';
// minimum length of chars to type before starting to start querying
const MIN_LENGTH = 3;
/*
 * An example of a 'detached' editor.
 * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.
 */
export class AutoCompleteEditor {
    constructor(args) {
        this.args = args;
        this._isValueTouched = false;
        this._lastTriggeredByClearInput = false;
        /** is the Editor disabled? */
        this.disabled = false;
        this.forceUserInput = false;
        /** Final collection displayed in the UI, that is after processing filter/sort/override */
        this.finalCollection = [];
        if (!args) {
            throw new Error('[Slickgrid-Universal] Something is wrong with this grid, an Editor must always have valid arguments.');
        }
        this.grid = args.grid;
        this.init();
    }
    /** Getter for the Autocomplete Option */
    get autoCompleteOptions() {
        return this._autoCompleteOptions || {};
    }
    /** Getter of the Collection */
    get collection() {
        var _a, _b;
        return (_b = (_a = this.columnEditor) === null || _a === void 0 ? void 0 : _a.collection) !== null && _b !== void 0 ? _b : [];
    }
    /** Getter for the Editor DOM Element */
    get editorDomElement() {
        return this._$input;
    }
    /** Getter for the Final Collection used in the AutoCompleted Source (this may vary from the "collection" especially when providing a customStructure) */
    get elementCollection() {
        return this._elementCollection;
    }
    /** Get Column Definition object */
    get columnDef() {
        return this.args.column;
    }
    /** Get Column Editor object */
    get columnEditor() {
        var _a;
        return ((_a = this.columnDef) === null || _a === void 0 ? void 0 : _a.internalColumnEditor) || {};
    }
    /** Getter for the Custom Structure if exist */
    get customStructure() {
        var _a, _b, _c, _d, _e, _f;
        let customStructure = (_a = this.columnEditor) === null || _a === void 0 ? void 0 : _a.customStructure;
        const columnType = (_c = (_b = this.columnEditor) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : (_d = this.columnDef) === null || _d === void 0 ? void 0 : _d.type;
        if (!customStructure && (columnType === FieldType.object && ((_e = this.columnDef) === null || _e === void 0 ? void 0 : _e.dataKey) && ((_f = this.columnDef) === null || _f === void 0 ? void 0 : _f.labelKey))) {
            customStructure = {
                label: this.columnDef.labelKey,
                value: this.columnDef.dataKey,
            };
        }
        return customStructure;
    }
    /** Getter for the item data context object */
    get dataContext() {
        return this.args.item;
    }
    get editorOptions() {
        var _a;
        return ((_a = this.columnEditor) === null || _a === void 0 ? void 0 : _a.editorOptions) || {};
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get gridOptions() {
        return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
    }
    /** jQuery UI AutoComplete instance */
    get instance() {
        return this._$input.autocomplete('instance');
    }
    get hasAutoCommitEdit() {
        var _a;
        return (_a = this.gridOptions.autoCommitEdit) !== null && _a !== void 0 ? _a : false;
    }
    /** Get the Validator function, can be passed in Editor property or Column Definition */
    get validator() {
        var _a, _b, _c;
        return (_b = (_a = this.columnEditor) === null || _a === void 0 ? void 0 : _a.validator) !== null && _b !== void 0 ? _b : (_c = this.columnDef) === null || _c === void 0 ? void 0 : _c.validator;
    }
    init() {
        var _a;
        this.labelName = this.customStructure && this.customStructure.label || 'label';
        this.valueName = this.customStructure && this.customStructure.value || 'value';
        this.labelPrefixName = this.customStructure && this.customStructure.labelPrefix || 'labelPrefix';
        this.labelSuffixName = this.customStructure && this.customStructure.labelSuffix || 'labelSuffix';
        // always render the DOM element, even if user passed a "collectionAsync",
        const newCollection = this.columnEditor.collection || [];
        this.renderDomElement(newCollection);
        // when having a collectionAsync and a collection that is empty, we'll toggle the Editor to disabled,
        // it will be re-enabled when we get the collection filled (in slick-vanilla-bundle on method "updateEditorCollection()")
        if (this.disabled || (((_a = this.columnEditor) === null || _a === void 0 ? void 0 : _a.collectionAsync) && Array.isArray(newCollection) && newCollection.length === 0)) {
            this.disable(true);
        }
    }
    destroy() {
        if (this._$input) {
            this._$input.autocomplete('destroy');
            this._$input.off('keydown.nav').remove();
        }
        this._$input = null;
        this._elementCollection = null;
    }
    /**
     * Dynamically change an Editor option, this is especially useful with Composite Editor
     * since this is the only way to change option after the Editor is created (for example dynamically change "minDate" or another Editor)
     * @param {string} optionName - MultipleSelect option name
     * @param {newValue} newValue - MultipleSelect new option value
     */
    changeEditorOption(optionName, newValue) {
        if (!this.columnEditor.editorOptions) {
            this.columnEditor.editorOptions = {};
        }
        this.columnEditor.editorOptions[optionName] = newValue;
        this._autoCompleteOptions = { ...this._autoCompleteOptions, [optionName]: newValue };
        this._$input.autocomplete('option', optionName, newValue);
    }
    disable(isDisabled = true) {
        var _a;
        const prevIsDisabled = this.disabled;
        this.disabled = isDisabled;
        if (this._$input) {
            if (isDisabled) {
                this._$input.attr('disabled', 'disabled');
                // clear value when it's newly disabled and not empty
                const currentValue = this.getValue();
                if (prevIsDisabled !== isDisabled && ((_a = this.args) === null || _a === void 0 ? void 0 : _a.compositeEditorOptions) && currentValue !== '') {
                    this.clear(true);
                }
            }
            else {
                this._$input.removeAttr('disabled');
            }
        }
    }
    focus() {
        if (this._$input) {
            this._$input.focus().select();
        }
    }
    show() {
        var _a;
        const isCompositeEditor = !!((_a = this.args) === null || _a === void 0 ? void 0 : _a.compositeEditorOptions);
        if (isCompositeEditor) {
            // when it's a Composite Editor, we'll check if the Editor is editable (by checking onBeforeEditCell) and if not Editable we'll disable the Editor
            this.applyInputUsabilityState();
        }
    }
    getValue() {
        return this._$input.val();
    }
    setValue(inputValue, isApplyingValue = false, triggerOnCompositeEditorChange = true) {
        var _a;
        let label = inputValue;
        // if user provided a custom structure, we will serialize the value returned from the object with custom structure
        if (inputValue && inputValue.hasOwnProperty(this.labelName)) {
            label = inputValue[this.labelName];
        }
        else {
            label = inputValue;
        }
        this._$input.val(label);
        if (isApplyingValue) {
            this._currentValue = inputValue;
            this._defaultTextValue = typeof inputValue === 'string' ? inputValue : ((_a = inputValue === null || inputValue === void 0 ? void 0 : inputValue[this.labelName]) !== null && _a !== void 0 ? _a : '');
            this.applyValue(this.args.item, this.serializeValue());
            // if it's set by a Composite Editor, then also trigger a change for it
            const compositeEditorOptions = this.args.compositeEditorOptions;
            if (compositeEditorOptions && triggerOnCompositeEditorChange) {
                this.handleChangeOnCompositeEditor(null, compositeEditorOptions, 'system');
            }
        }
    }
    applyValue(item, state) {
        var _a, _b, _c;
        let newValue = state;
        const fieldName = this.columnDef && this.columnDef.field;
        if (fieldName !== undefined) {
            // if we have a collection defined, we will try to find the string within the collection and return it
            if (Array.isArray(this.collection) && this.collection.length > 0) {
                newValue = findOrDefault(this.collection, (collectionItem) => {
                    if (collectionItem && typeof state === 'object' && collectionItem.hasOwnProperty(this.labelName)) {
                        return (collectionItem.hasOwnProperty(this.labelName) && collectionItem[this.labelName].toString()) === (state.hasOwnProperty(this.labelName) && state[this.labelName].toString());
                    }
                    else if (collectionItem && typeof state === 'string' && collectionItem.hasOwnProperty(this.labelName)) {
                        return (collectionItem.hasOwnProperty(this.labelName) && collectionItem[this.labelName].toString()) === state;
                    }
                    return collectionItem && collectionItem.toString() === state;
                });
            }
            // is the field a complex object, "address.streetNumber"
            const isComplexObject = (fieldName === null || fieldName === void 0 ? void 0 : fieldName.indexOf('.')) > 0;
            // validate the value before applying it (if not valid we'll set an empty string)
            const validation = this.validate(null, newValue);
            newValue = (validation && validation.valid) ? newValue : '';
            // set the new value to the item datacontext
            if (isComplexObject) {
                // when it's a complex object, user could override the object path (where the editable object is located)
                // else we use the path provided in the Field Column Definition
                const objectPath = (_c = (_b = (_a = this.columnEditor) === null || _a === void 0 ? void 0 : _a.complexObjectPath) !== null && _b !== void 0 ? _b : fieldName) !== null && _c !== void 0 ? _c : '';
                setDeepValue(item, objectPath, newValue);
            }
            else {
                item[fieldName] = newValue;
            }
        }
    }
    isValueChanged() {
        const elmValue = this._$input.val();
        const lastKeyEvent = this._lastInputKeyEvent && this._lastInputKeyEvent.keyCode;
        if (this.columnEditor && this.columnEditor.alwaysSaveOnEnterKey && lastKeyEvent === KeyCode.ENTER) {
            return true;
        }
        const isValueChanged = (!(elmValue === '' && (this._defaultTextValue === null || this._defaultTextValue === undefined))) && (elmValue !== this._defaultTextValue);
        return this._lastTriggeredByClearInput || isValueChanged;
    }
    isValueTouched() {
        return this._isValueTouched;
    }
    loadValue(item) {
        var _a;
        const fieldName = this.columnDef && this.columnDef.field;
        if (item && fieldName !== undefined) {
            // is the field a complex object, "address.streetNumber"
            const isComplexObject = (fieldName === null || fieldName === void 0 ? void 0 : fieldName.indexOf('.')) > 0;
            const data = (isComplexObject) ? getDescendantProperty(item, fieldName) : item[fieldName];
            this._currentValue = data;
            this._originalValue = data;
            this._defaultTextValue = typeof data === 'string' ? data : ((_a = data === null || data === void 0 ? void 0 : data[this.labelName]) !== null && _a !== void 0 ? _a : '');
            this._$input.val(this._defaultTextValue);
            this._$input.select();
        }
    }
    clear(clearByDisableCommand = false) {
        if (this._$input) {
            this._currentValue = '';
            this._defaultTextValue = '';
            this.setValue('', true); // set the input value and also apply the change to the datacontext item
        }
        this._isValueTouched = true;
        this._lastTriggeredByClearInput = true;
        const compositeEditorOptions = this.args.compositeEditorOptions;
        if (compositeEditorOptions) {
            const shouldDeleteFormValue = !clearByDisableCommand;
            this.handleChangeOnCompositeEditor(null, compositeEditorOptions, 'user', shouldDeleteFormValue);
        }
        else {
            this.save();
        }
    }
    /**
     * You can reset the input value,
     * when no value is provided it will use the original value to reset (could be useful with Composite Editor Modal with edit/clone)
     */
    reset(value, triggerCompositeEventWhenExist = true, clearByDisableCommand = false) {
        var _a, _b;
        const inputValue = (_a = value !== null && value !== void 0 ? value : this._originalValue) !== null && _a !== void 0 ? _a : '';
        if (this._$input) {
            this._currentValue = inputValue;
            this._defaultTextValue = typeof inputValue === 'string' ? inputValue : ((_b = inputValue === null || inputValue === void 0 ? void 0 : inputValue[this.labelName]) !== null && _b !== void 0 ? _b : '');
            this._$input.val(this._defaultTextValue);
        }
        this._isValueTouched = false;
        const compositeEditorOptions = this.args.compositeEditorOptions;
        if (compositeEditorOptions && triggerCompositeEventWhenExist) {
            const shouldDeleteFormValue = !clearByDisableCommand;
            this.handleChangeOnCompositeEditor(null, compositeEditorOptions, 'user', shouldDeleteFormValue);
        }
    }
    save() {
        const validation = this.validate();
        const isValid = (validation && validation.valid) || false;
        if (this.hasAutoCommitEdit && isValid) {
            // do not use args.commitChanges() as this sets the focus to the next row.
            // also the select list will stay shown when clicking off the grid
            this.grid.getEditorLock().commitCurrentEdit();
        }
        else {
            this.args.commitChanges();
        }
    }
    serializeValue() {
        var _a, _b, _c, _d, _e, _f;
        // if you want to add the autocomplete functionality but want the user to be able to input a new option
        if (this.editorOptions.forceUserInput) {
            const minLength = (_b = (_a = this.editorOptions) === null || _a === void 0 ? void 0 : _a.minLength) !== null && _b !== void 0 ? _b : MIN_LENGTH;
            this._currentValue = this._$input.val().length > minLength ? this._$input.val() : this._currentValue;
        }
        // if user provided a custom structure, we will serialize the value returned from the object with custom structure
        if (this.customStructure && this._currentValue && this._currentValue.hasOwnProperty(this.valueName) && (((_c = this.columnDef) === null || _c === void 0 ? void 0 : _c.type) !== FieldType.object && ((_d = this.columnEditor) === null || _d === void 0 ? void 0 : _d.type) !== FieldType.object)) {
            return this._currentValue[this.valueName];
        }
        else if (this._currentValue && this._currentValue.value !== undefined) {
            // when object has a "value" property and its column is set as an Object type, we'll return an object with optional custom structure
            if (((_e = this.columnDef) === null || _e === void 0 ? void 0 : _e.type) === FieldType.object || ((_f = this.columnEditor) === null || _f === void 0 ? void 0 : _f.type) === FieldType.object) {
                return {
                    [this.labelName]: this._currentValue.label,
                    [this.valueName]: this._currentValue.value
                };
            }
            return this._currentValue.value;
        }
        // if it falls here it might be that the user provided its own custom item with something else than the regular label/value pair
        // at this point it's only available when user provide a custom template for the autocomplete renderItem callback
        return this._currentValue;
    }
    validate(_targetElm, inputValue) {
        var _a, _b;
        // when using Composite Editor, we also want to recheck if the field if disabled/enabled since it might change depending on other inputs on the composite form
        if (this.args.compositeEditorOptions) {
            this.applyInputUsabilityState();
        }
        // when field is disabled, we can assume it's valid
        if (this.disabled) {
            return { valid: true, msg: '' };
        }
        const val = (inputValue !== undefined) ? inputValue : (_a = this._$input) === null || _a === void 0 ? void 0 : _a.val();
        return textValidator(val, {
            editorArgs: this.args,
            errorMessage: this.columnEditor.errorMessage,
            minLength: this.columnEditor.minLength,
            maxLength: this.columnEditor.maxLength,
            operatorConditionalType: this.columnEditor.operatorConditionalType,
            required: ((_b = this.args) === null || _b === void 0 ? void 0 : _b.compositeEditorOptions) ? false : this.columnEditor.required,
            validator: this.validator,
        });
    }
    //
    // protected functions
    // ------------------
    /** when it's a Composite Editor, we'll check if the Editor is editable (by checking onBeforeEditCell) and if not Editable we'll disable the Editor */
    applyInputUsabilityState() {
        const activeCell = this.grid.getActiveCell();
        const isCellEditable = this.grid.onBeforeEditCell.notify({
            ...activeCell, item: this.dataContext, column: this.args.column, grid: this.grid, target: 'composite', compositeEditorOptions: this.args.compositeEditorOptions
        });
        this.disable(isCellEditable === false);
    }
    handleChangeOnCompositeEditor(event, compositeEditorOptions, triggeredBy = 'user', isCalledByClearValue = false) {
        var _a, _b, _c, _d, _e;
        const activeCell = this.grid.getActiveCell();
        const column = this.args.column;
        const columnId = (_b = (_a = this.columnDef) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : '';
        const item = this.dataContext;
        const grid = this.grid;
        const newValue = this.serializeValue();
        // when valid, we'll also apply the new value to the dataContext item object
        if (this.validate().valid) {
            this.applyValue(this.dataContext, newValue);
        }
        this.applyValue(compositeEditorOptions.formValues, newValue);
        const isExcludeDisabledFieldFormValues = (_e = (_d = (_c = this.gridOptions) === null || _c === void 0 ? void 0 : _c.compositeEditorOptions) === null || _d === void 0 ? void 0 : _d.excludeDisabledFieldFormValues) !== null && _e !== void 0 ? _e : false;
        if (isCalledByClearValue || (this.disabled && isExcludeDisabledFieldFormValues && compositeEditorOptions.formValues.hasOwnProperty(columnId))) {
            delete compositeEditorOptions.formValues[columnId]; // when the input is disabled we won't include it in the form result object
        }
        grid.onCompositeEditorChange.notify({ ...activeCell, item, grid, column, formValues: compositeEditorOptions.formValues, editors: compositeEditorOptions.editors, triggeredBy }, { ...new Slick.EventData(), ...event });
    }
    // this function should be protected but for unit tests purposes we'll make it public until a better solution is found
    // a better solution would be to get the autocomplete DOM element to work with selection but I couldn't find how to do that in Jest
    handleSelect(event, ui) {
        var _a, _b, _c, _d, _e, _f;
        if (ui && ui.item) {
            const selectedItem = ui && ui.item;
            this._currentValue = selectedItem;
            this._isValueTouched = true;
            const compositeEditorOptions = this.args.compositeEditorOptions;
            // when the user defines a "renderItem" (or "_renderItem") template, then we assume the user defines his own custom structure of label/value pair
            // otherwise we know that jQueryUI always require a label/value pair, we can pull them directly
            const hasCustomRenderItemCallback = (_f = (_c = (_b = (_a = this.columnEditor) === null || _a === void 0 ? void 0 : _a.callbacks) === null || _b === void 0 ? void 0 : _b.hasOwnProperty('_renderItem')) !== null && _c !== void 0 ? _c : (_e = (_d = this.columnEditor) === null || _d === void 0 ? void 0 : _d.editorOptions) === null || _e === void 0 ? void 0 : _e.renderItem) !== null && _f !== void 0 ? _f : false;
            const itemLabel = typeof selectedItem === 'string' ? selectedItem : (hasCustomRenderItemCallback ? selectedItem[this.labelName] : selectedItem.label);
            this.setValue(itemLabel);
            if (compositeEditorOptions) {
                this.handleChangeOnCompositeEditor(event, compositeEditorOptions);
            }
            else {
                this.save();
            }
            // if user wants to hook to the "select", he can do via this "onSelect"
            // it purposely has a similar signature as the "select" callback + some extra arguments (row, cell, column, dataContext)
            if (this.editorOptions.onSelect) {
                const activeCell = this.grid.getActiveCell();
                this.editorOptions.onSelect(event, ui, activeCell.row, activeCell.cell, this.args.column, this.args.item);
            }
            setTimeout(() => this._lastTriggeredByClearInput = false); // reset flag after a cycle
        }
        return false;
    }
    renderCustomItem(ul, item) {
        var _a, _b, _c;
        const templateString = (_c = (_b = (_a = this._autoCompleteOptions) === null || _a === void 0 ? void 0 : _a.renderItem) === null || _b === void 0 ? void 0 : _b.templateCallback(item)) !== null && _c !== void 0 ? _c : '';
        // sanitize any unauthorized html tags like script and others
        // for the remaining allowed tags we'll permit all attributes
        const sanitizedTemplateText = sanitizeTextByAvailableSanitizer(this.gridOptions, templateString) || '';
        return $('<li></li>')
            .data('item.autocomplete', item)
            .append(sanitizedTemplateText)
            .appendTo(ul);
    }
    renderCollectionItem(ul, item) {
        var _a, _b;
        const isRenderHtmlEnabled = (_b = (_a = this.columnEditor) === null || _a === void 0 ? void 0 : _a.enableRenderHtml) !== null && _b !== void 0 ? _b : false;
        const prefixText = item.labelPrefix || '';
        const labelText = item.label || '';
        const suffixText = item.labelSuffix || '';
        const finalText = prefixText + labelText + suffixText;
        // sanitize any unauthorized html tags like script and others
        // for the remaining allowed tags we'll permit all attributes
        const sanitizedText = sanitizeTextByAvailableSanitizer(this.gridOptions, finalText) || '';
        const $liDiv = $('<div></div>')[isRenderHtmlEnabled ? 'html' : 'text'](sanitizedText);
        return $('<li></li>')
            .data('item.autocomplete', item)
            .append($liDiv)
            .appendTo(ul);
    }
    renderDomElement(collection) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (!Array.isArray(collection)) {
            throw new Error('The "collection" passed to the Autocomplete Editor is not a valid array.');
        }
        const columnId = (_b = (_a = this.columnDef) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : '';
        const placeholder = (_d = (_c = this.columnEditor) === null || _c === void 0 ? void 0 : _c.placeholder) !== null && _d !== void 0 ? _d : '';
        const title = (_f = (_e = this.columnEditor) === null || _e === void 0 ? void 0 : _e.title) !== null && _f !== void 0 ? _f : '';
        this._$input = $(`<input type="text" role="presentation" autocomplete="off" class="autocomplete form-control editor-text editor-${columnId}" placeholder="${placeholder}" title="${title}" />`)
            .appendTo(this.args.container)
            .on('keydown.nav', (event) => {
            this._lastInputKeyEvent = event;
            if (event.keyCode === KeyCode.LEFT || event.keyCode === KeyCode.RIGHT) {
                event.stopImmediatePropagation();
            }
        });
        // append the new DOM element to the slick cell container,
        // we need the autocomplete-container so that the spinner is aligned properly with the Composite Editor
        if (this._$input && typeof this._$input.appendTo === 'function') {
            this._$editorInputGroupElm = $(`<div class="autocomplete-container input-group"></div>`);
            this._$editorInputGroupElm.appendTo(this.args.container);
            this._$input.appendTo(this._$editorInputGroupElm);
            this._$input.addClass('input-group-editor');
            const $closeButtonGroupElm = $(`<span class="input-group-btn input-group-append" data-clear></span>`);
            this._$closeButtonGroupElm = $(`<button class="btn btn-default icon-clear" type="button"></button>`);
            // add an empty <span> in order to add loading spinner styling
            $(`<span></span>`).appendTo(this._$editorInputGroupElm);
            // show clear date button (unless user specifically doesn't want it)
            if (!((_h = (_g = this.columnEditor) === null || _g === void 0 ? void 0 : _g.params) === null || _h === void 0 ? void 0 : _h.hideClearButton)) {
                this._$closeButtonGroupElm.appendTo($closeButtonGroupElm);
                $closeButtonGroupElm.appendTo(this._$editorInputGroupElm);
                this._$closeButtonGroupElm.on('click', this.clear.bind(this));
            }
        }
        // user might pass his own autocomplete options
        const autoCompleteOptions = this.columnEditor.editorOptions;
        // assign the collection to a temp variable before filtering/sorting the collection
        let finalCollection = collection;
        // user could also override the collection
        if ((_j = this.columnEditor) === null || _j === void 0 ? void 0 : _j.collectionOverride) {
            const overrideArgs = { column: this.columnDef, dataContext: this.dataContext, grid: this.grid, originalCollections: this.collection };
            if (this.args.compositeEditorOptions) {
                const { formValues, modalType } = this.args.compositeEditorOptions;
                overrideArgs.compositeEditorOptions = { formValues, modalType };
            }
            finalCollection = this.columnEditor.collectionOverride(finalCollection, overrideArgs);
        }
        // keep reference of the final collection displayed in the UI
        this.finalCollection = finalCollection;
        // user might provide his own custom structure
        // jQuery UI autocomplete requires a label/value pair, so we must remap them when user provide different ones
        if (Array.isArray(finalCollection)) {
            finalCollection = finalCollection.map((item) => {
                return { label: item[this.labelName], value: item[this.valueName], labelPrefix: item[this.labelPrefixName] || '', labelSuffix: item[this.labelSuffixName] || '' };
            });
        }
        // keep the final source collection used in the AutoComplete as reference
        this._elementCollection = finalCollection;
        // when user passes it's own autocomplete options
        // we still need to provide our own "select" callback implementation
        if (autoCompleteOptions === null || autoCompleteOptions === void 0 ? void 0 : autoCompleteOptions.source) {
            autoCompleteOptions.select = (event, ui) => this.handleSelect(event, ui);
            this._autoCompleteOptions = { ...autoCompleteOptions };
            // when "renderItem" is defined, we need to add our custom style CSS class
            if (this._autoCompleteOptions.renderItem) {
                this._autoCompleteOptions.classes = {
                    'ui-autocomplete': `autocomplete-custom-${toKebabCase(this._autoCompleteOptions.renderItem.layout)}`
                };
            }
            // create the jQueryUI AutoComplete
            this._$input.autocomplete(this._autoCompleteOptions);
            // when "renderItem" is defined, we need to call the user's custom renderItem template callback
            if (this._autoCompleteOptions.renderItem) {
                this._$input.autocomplete('instance')._renderItem = this.renderCustomItem.bind(this);
            }
        }
        else {
            const definedOptions = {
                source: finalCollection,
                minLength: 0,
                select: (event, ui) => this.handleSelect(event, ui),
            };
            this._autoCompleteOptions = { ...definedOptions, ...this.columnEditor.editorOptions };
            this._$input.autocomplete(this._autoCompleteOptions);
            // we'll use our own renderer so that it works with label prefix/suffix and also with html rendering when enabled
            this._$input.autocomplete('instance')._renderItem = this.renderCollectionItem.bind(this);
        }
        // in case the user wants to save even an empty value,
        // we need to subscribe to the onKeyDown event for that use case and clear the current value
        if (this.columnEditor.alwaysSaveOnEnterKey) {
            this._$input.keydown((event) => {
                if (event.keyCode === KeyCode.ENTER) {
                    this._currentValue = null;
                }
            });
        }
        // user might override any of the jQueryUI callback methods
        if (this.columnEditor.callbacks) {
            for (const callback of Object.keys(this.columnEditor.callbacks)) {
                if (typeof this.columnEditor.callbacks[callback] === 'function') {
                    this.instance[callback] = this.columnEditor.callbacks[callback];
                }
            }
        }
        this._$input.on('focus', () => {
            this._$input.select();
            // we could optionally trigger a search to open the AutoComplete search list
            if (this.editorOptions.openSearchListOnFocus) {
                this._$input.autocomplete('search', this._$input.val());
            }
        });
        if (!this.args.compositeEditorOptions) {
            setTimeout(() => this.focus(), 50);
        }
    }
}
//# sourceMappingURL=autoCompleteEditor.js.map