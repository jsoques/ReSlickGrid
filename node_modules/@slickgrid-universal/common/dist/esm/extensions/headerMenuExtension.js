import 'slickgrid/plugins/slick.headermenu';
import { EmitterType } from '../enums/index';
import { arrayRemoveItemByIndex, getTranslationPrefix } from '../services/utilities';
export class HeaderMenuExtension {
    constructor(extensionUtility, filterService, pubSubService, sharedService, sortService, translaterService) {
        this.extensionUtility = extensionUtility;
        this.filterService = filterService;
        this.pubSubService = pubSubService;
        this.sharedService = sharedService;
        this.sortService = sortService;
        this.translaterService = translaterService;
        this._addon = null;
        this._eventHandler = new Slick.EventHandler();
    }
    get eventHandler() {
        return this._eventHandler;
    }
    dispose() {
        // unsubscribe all SlickGrid events
        this._eventHandler.unsubscribeAll();
        if (this._addon && this._addon.destroy) {
            this._addon.destroy();
        }
        this._addon = null;
    }
    /** Get the instance of the SlickGrid addon (control or plugin). */
    getAddonInstance() {
        return this._addon;
    }
    /** Register the 3rd party addon (plugin) */
    register() {
        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translaterService || !this.translaterService.translate)) {
            throw new Error('[Slickgrid-Universal] requires a Translate Service to be installed and configured when the grid option "enableTranslate" is enabled.');
        }
        if (this.sharedService && this.sharedService.slickGrid && this.sharedService.gridOptions) {
            this.sharedService.gridOptions.headerMenu = { ...this.getDefaultHeaderMenuOptions(), ...this.sharedService.gridOptions.headerMenu };
            if (this.sharedService.gridOptions.enableHeaderMenu) {
                this.sharedService.gridOptions.headerMenu = this.addHeaderMenuCustomCommands(this.sharedService.gridOptions, this.sharedService.columnDefinitions);
            }
            this._addon = new Slick.Plugins.HeaderMenu(this.sharedService.gridOptions.headerMenu);
            if (this._addon) {
                this.sharedService.slickGrid.registerPlugin(this._addon);
            }
            // hook all events
            if (this._addon && this.sharedService.slickGrid && this.sharedService.gridOptions.headerMenu) {
                if (this.sharedService.gridOptions.headerMenu.onExtensionRegistered) {
                    this.sharedService.gridOptions.headerMenu.onExtensionRegistered(this._addon);
                }
                const onCommandHandler = this._addon.onCommand;
                if (onCommandHandler) {
                    this._eventHandler.subscribe(onCommandHandler, (event, args) => {
                        this.executeHeaderMenuInternalCommands(event, args);
                        if (this.sharedService.gridOptions.headerMenu && typeof this.sharedService.gridOptions.headerMenu.onCommand === 'function') {
                            this.sharedService.gridOptions.headerMenu.onCommand(event, args);
                        }
                    });
                }
                if (this.sharedService.gridOptions.headerMenu && typeof this.sharedService.gridOptions.headerMenu.onBeforeMenuShow === 'function') {
                    const onBeforeMenuShowHandler = this._addon.onBeforeMenuShow;
                    if (onBeforeMenuShowHandler) {
                        this._eventHandler.subscribe(onBeforeMenuShowHandler, (event, args) => {
                            if (this.sharedService.gridOptions.headerMenu && this.sharedService.gridOptions.headerMenu.onBeforeMenuShow) {
                                this.sharedService.gridOptions.headerMenu.onBeforeMenuShow(event, args);
                            }
                        });
                    }
                }
                if (this.sharedService.gridOptions.headerMenu && typeof this.sharedService.gridOptions.headerMenu.onAfterMenuShow === 'function') {
                    const onAfterMenuShowHandler = this._addon.onAfterMenuShow;
                    if (onAfterMenuShowHandler) {
                        this._eventHandler.subscribe(onAfterMenuShowHandler, (event, args) => {
                            if (this.sharedService.gridOptions.headerMenu && this.sharedService.gridOptions.headerMenu.onAfterMenuShow) {
                                this.sharedService.gridOptions.headerMenu.onAfterMenuShow(event, args);
                            }
                        });
                    }
                }
            }
            return this._addon;
        }
        return null;
    }
    /**
     * Create Header Menu with Custom Commands if user has enabled Header Menu
     * @param options
     * @param columnDefinitions
     * @return header menu
     */
    addHeaderMenuCustomCommands(options, columnDefinitions) {
        const headerMenuOptions = options.headerMenu || {};
        const gridOptions = this.sharedService.gridOptions;
        const translationPrefix = getTranslationPrefix(gridOptions);
        if (columnDefinitions && Array.isArray(columnDefinitions) && options.enableHeaderMenu) {
            columnDefinitions.forEach((columnDef) => {
                var _a, _b, _c;
                if (columnDef && !columnDef.excludeFromHeaderMenu) {
                    if (!columnDef.header || !columnDef.header.menu) {
                        columnDef.header = {
                            menu: {
                                items: []
                            }
                        };
                    }
                    const columnHeaderMenuItems = (_c = (_b = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.header) === null || _a === void 0 ? void 0 : _a.menu) === null || _b === void 0 ? void 0 : _b.items) !== null && _c !== void 0 ? _c : [];
                    // Freeze Column (pinning)
                    let hasFrozenOrResizeCommand = false;
                    if (headerMenuOptions && !headerMenuOptions.hideFreezeColumnsCommand) {
                        hasFrozenOrResizeCommand = true;
                        if (!columnHeaderMenuItems.some(item => item !== 'divider' && item.hasOwnProperty('command') && item.command === 'freeze-columns')) {
                            columnHeaderMenuItems.push({
                                iconCssClass: headerMenuOptions.iconFreezeColumns || 'fa fa-thumb-tack',
                                title: this.extensionUtility.translateWhenEnabledAndServiceExist(`${translationPrefix}FREEZE_COLUMNS`, 'TEXT_FREEZE_COLUMNS'),
                                command: 'freeze-columns',
                                positionOrder: 47
                            });
                        }
                    }
                    // Column Resize by Content (column autofit)
                    if (headerMenuOptions && !headerMenuOptions.hideColumnResizeByContentCommand && this.sharedService.gridOptions.enableColumnResizeOnDoubleClick) {
                        hasFrozenOrResizeCommand = true;
                        if (!columnHeaderMenuItems.some(item => item !== 'divider' && item.hasOwnProperty('command') && item.command === 'column-resize-by-content')) {
                            columnHeaderMenuItems.push({
                                iconCssClass: headerMenuOptions.iconColumnResizeByContentCommand || 'fa fa-arrows-h',
                                title: this.extensionUtility.translateWhenEnabledAndServiceExist(`${translationPrefix}COLUMN_RESIZE_BY_CONTENT`, 'TEXT_COLUMN_RESIZE_BY_CONTENT'),
                                command: 'column-resize-by-content',
                                positionOrder: 48
                            });
                        }
                    }
                    // add a divider (separator) between the top freeze columns commands and the rest of the commands
                    if (hasFrozenOrResizeCommand && !columnHeaderMenuItems.some(item => item !== 'divider' && item.positionOrder === 49)) {
                        columnHeaderMenuItems.push({ divider: true, command: '', positionOrder: 49 });
                    }
                    // Sorting Commands
                    if (options.enableSorting && columnDef.sortable && headerMenuOptions && !headerMenuOptions.hideSortCommands) {
                        if (!columnHeaderMenuItems.some(item => item !== 'divider' && item.hasOwnProperty('command') && item.command === 'sort-asc')) {
                            columnHeaderMenuItems.push({
                                iconCssClass: headerMenuOptions.iconSortAscCommand || 'fa fa-sort-asc',
                                title: this.extensionUtility.translateWhenEnabledAndServiceExist(`${translationPrefix}SORT_ASCENDING`, 'TEXT_SORT_ASCENDING'),
                                command: 'sort-asc',
                                positionOrder: 50
                            });
                        }
                        if (!columnHeaderMenuItems.some(item => item !== 'divider' && item.hasOwnProperty('command') && item.command === 'sort-desc')) {
                            columnHeaderMenuItems.push({
                                iconCssClass: headerMenuOptions.iconSortDescCommand || 'fa fa-sort-desc',
                                title: this.extensionUtility.translateWhenEnabledAndServiceExist(`${translationPrefix}SORT_DESCENDING`, 'TEXT_SORT_DESCENDING'),
                                command: 'sort-desc',
                                positionOrder: 51
                            });
                        }
                        // add a divider (separator) between the top sort commands and the other clear commands
                        if (!columnHeaderMenuItems.some(item => item !== 'divider' && item.positionOrder === 52)) {
                            columnHeaderMenuItems.push({ divider: true, command: '', positionOrder: 52 });
                        }
                        if (!headerMenuOptions.hideClearSortCommand && !columnHeaderMenuItems.some(item => item !== 'divider' && item.hasOwnProperty('command') && item.command === 'clear-sort')) {
                            columnHeaderMenuItems.push({
                                iconCssClass: headerMenuOptions.iconClearSortCommand || 'fa fa-unsorted',
                                title: this.extensionUtility.translateWhenEnabledAndServiceExist(`${translationPrefix}REMOVE_SORT`, 'TEXT_REMOVE_SORT'),
                                command: 'clear-sort',
                                positionOrder: 54
                            });
                        }
                    }
                    // Filtering Commands
                    if (options.enableFiltering && columnDef.filterable && headerMenuOptions && !headerMenuOptions.hideFilterCommand) {
                        if (!headerMenuOptions.hideClearFilterCommand && !columnHeaderMenuItems.some(item => item !== 'divider' && item.hasOwnProperty('command') && item.command === 'clear-filter')) {
                            columnHeaderMenuItems.push({
                                iconCssClass: headerMenuOptions.iconClearFilterCommand || 'fa fa-filter',
                                title: this.extensionUtility.translateWhenEnabledAndServiceExist(`${translationPrefix}REMOVE_FILTER`, 'TEXT_REMOVE_FILTER'),
                                command: 'clear-filter',
                                positionOrder: 53
                            });
                        }
                    }
                    // Hide Column Command
                    if (headerMenuOptions && !headerMenuOptions.hideColumnHideCommand && !columnHeaderMenuItems.some(item => item !== 'divider' && item.hasOwnProperty('command') && item.command === 'hide')) {
                        columnHeaderMenuItems.push({
                            iconCssClass: headerMenuOptions.iconColumnHideCommand || 'fa fa-times',
                            title: this.extensionUtility.translateWhenEnabledAndServiceExist(`${translationPrefix}HIDE_COLUMN`, 'TEXT_HIDE_COLUMN'),
                            command: 'hide',
                            positionOrder: 55
                        });
                    }
                    this.extensionUtility.translateItems(columnHeaderMenuItems, 'titleKey', 'title');
                    this.extensionUtility.sortItems(columnHeaderMenuItems, 'positionOrder');
                }
            });
        }
        return headerMenuOptions;
    }
    /** Hide a column from the grid */
    hideColumn(column) {
        var _a, _b, _c;
        if ((_b = (_a = this.sharedService) === null || _a === void 0 ? void 0 : _a.slickGrid) === null || _b === void 0 ? void 0 : _b.getColumnIndex) {
            const columnIndex = this.sharedService.slickGrid.getColumnIndex(column.id);
            const currentVisibleColumns = this.sharedService.slickGrid.getColumns();
            // if we're using frozen columns, we need to readjust pinning when the new hidden column is on the left pinning container
            // we need to do this because SlickGrid freezes by index and has no knowledge of the columns themselves
            const frozenColumnIndex = (_c = this.sharedService.gridOptions.frozenColumn) !== null && _c !== void 0 ? _c : -1;
            if (frozenColumnIndex >= 0 && frozenColumnIndex >= columnIndex) {
                this.sharedService.gridOptions.frozenColumn = frozenColumnIndex - 1;
                this.sharedService.slickGrid.setOptions({ frozenColumn: this.sharedService.gridOptions.frozenColumn });
            }
            // then proceed with hiding the column in SlickGrid & trigger an event when done
            const visibleColumns = arrayRemoveItemByIndex(currentVisibleColumns, columnIndex);
            this.sharedService.visibleColumns = visibleColumns;
            this.sharedService.slickGrid.setColumns(visibleColumns);
            this.pubSubService.publish('onHeaderMenuHideColumns', { columns: visibleColumns, hiddenColumn: column });
        }
    }
    /** Translate the Header Menu titles, we need to loop through all column definition to re-translate them */
    translateHeaderMenu() {
        var _a;
        if ((_a = this.sharedService.gridOptions) === null || _a === void 0 ? void 0 : _a.headerMenu) {
            this.resetHeaderMenuTranslations(this.sharedService.visibleColumns);
        }
    }
    /**
     * @return default Header Menu options
     */
    getDefaultHeaderMenuOptions() {
        return {
            autoAlignOffset: 12,
            minWidth: 140,
            hideColumnHideCommand: false,
            hideSortCommands: false,
            title: ''
        };
    }
    /**
     * Reset all the internal Menu options which have text to translate
     * @param header menu object
     */
    resetHeaderMenuTranslations(columnDefinitions) {
        const gridOptions = this.sharedService.gridOptions;
        const translationPrefix = getTranslationPrefix(gridOptions);
        columnDefinitions.forEach((columnDef) => {
            var _a, _b;
            if ((_b = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.header) === null || _a === void 0 ? void 0 : _a.menu) === null || _b === void 0 ? void 0 : _b.items) {
                if (!columnDef.excludeFromHeaderMenu) {
                    const columnHeaderMenuItems = columnDef.header.menu.items || [];
                    columnHeaderMenuItems.forEach(item => {
                        if (item !== 'divider' && item.hasOwnProperty('command')) {
                            switch (item.command) {
                                case 'column-resize-by-content':
                                    item.title = this.extensionUtility.translateWhenEnabledAndServiceExist(`${translationPrefix}COLUMN_RESIZE_BY_CONTENT`, 'TEXT_COLUMN_RESIZE_BY_CONTENT');
                                    break;
                                case 'clear-filter':
                                    item.title = this.extensionUtility.translateWhenEnabledAndServiceExist(`${translationPrefix}REMOVE_FILTER`, 'TEXT_REMOVE_FILTER');
                                    break;
                                case 'clear-sort':
                                    item.title = this.extensionUtility.translateWhenEnabledAndServiceExist(`${translationPrefix}REMOVE_SORT`, 'TEXT_REMOVE_SORT');
                                    break;
                                case 'freeze-columns':
                                    item.title = this.extensionUtility.translateWhenEnabledAndServiceExist(`${translationPrefix}FREEZE_COLUMNS`, 'TEXT_FREEZE_COLUMNS');
                                    break;
                                case 'sort-asc':
                                    item.title = this.extensionUtility.translateWhenEnabledAndServiceExist(`${translationPrefix}SORT_ASCENDING`, 'TEXT_SORT_ASCENDING');
                                    break;
                                case 'sort-desc':
                                    item.title = this.extensionUtility.translateWhenEnabledAndServiceExist(`${translationPrefix}SORT_DESCENDING`, 'TEXT_SORT_DESCENDING');
                                    break;
                                case 'hide':
                                    item.title = this.extensionUtility.translateWhenEnabledAndServiceExist(`${translationPrefix}HIDE_COLUMN`, 'TEXT_HIDE_COLUMN');
                                    break;
                            }
                        }
                        // re-translate if there's a "titleKey"
                        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate) {
                            this.extensionUtility.translateItems(columnHeaderMenuItems, 'titleKey', 'title');
                        }
                    });
                }
            }
        });
    }
    // --
    // private functions
    // ------------------
    /** Clear the Filter on the current column (if it's actually filtered) */
    clearColumnFilter(event, args) {
        if (args === null || args === void 0 ? void 0 : args.column) {
            this.filterService.clearFilterByColumnId(event, args.column.id);
        }
    }
    /** Clear the Sort on the current column (if it's actually sorted) */
    clearColumnSort(event, args) {
        if ((args === null || args === void 0 ? void 0 : args.column) && this.sharedService) {
            this.sortService.clearSortByColumnId(event, args.column.id);
        }
    }
    /** Execute the Header Menu Commands that was triggered by the onCommand subscribe */
    executeHeaderMenuInternalCommands(event, args) {
        var _a;
        if (args === null || args === void 0 ? void 0 : args.command) {
            switch (args.command) {
                case 'hide':
                    this.hideColumn(args.column);
                    if ((_a = this.sharedService.gridOptions) === null || _a === void 0 ? void 0 : _a.enableAutoSizeColumns) {
                        this.sharedService.slickGrid.autosizeColumns();
                    }
                    break;
                case 'clear-filter':
                    this.clearColumnFilter(event, args);
                    break;
                case 'clear-sort':
                    this.clearColumnSort(event, args);
                    break;
                case 'column-resize-by-content':
                    this.pubSubService.publish('onHeaderMenuColumnResizeByContent', { columnId: args.column.id });
                    break;
                case 'freeze-columns':
                    const visibleColumns = [...this.sharedService.visibleColumns];
                    const columnPosition = visibleColumns.findIndex(col => col.id === args.column.id);
                    const newGridOptions = { frozenColumn: columnPosition, enableMouseWheelScrollHandler: true };
                    // to circumvent a bug in SlickGrid core lib, let's keep the columns positions ref and re-apply them after calling setOptions
                    // the bug is highlighted in this issue comment:: https://github.com/6pac/SlickGrid/issues/592#issuecomment-822885069
                    const previousColumnDefinitions = this.sharedService.slickGrid.getColumns();
                    this.sharedService.slickGrid.setOptions(newGridOptions, false, true); // suppress the setColumns (3rd argument) since we'll do that ourselves
                    this.sharedService.gridOptions.frozenColumn = newGridOptions.frozenColumn;
                    this.sharedService.gridOptions.enableMouseWheelScrollHandler = newGridOptions.enableMouseWheelScrollHandler;
                    this.sharedService.frozenVisibleColumnId = args.column.id;
                    // to freeze columns, we need to take only the visible columns and we also need to use setColumns() when some of them are hidden
                    // to make sure that we only use the visible columns, not doing this will have the undesired effect of showing back some of the hidden columns
                    if (this.sharedService.hasColumnsReordered || (Array.isArray(visibleColumns) && Array.isArray(this.sharedService.allColumns) && visibleColumns.length !== this.sharedService.allColumns.length)) {
                        this.sharedService.slickGrid.setColumns(visibleColumns);
                    }
                    else {
                        // to circumvent a bug in SlickGrid core lib re-apply same column definitions that were backend up before calling setOptions()
                        this.sharedService.slickGrid.setColumns(previousColumnDefinitions);
                    }
                    // we also need to autosize columns if the option is enabled
                    const gridOptions = this.sharedService.slickGrid.getOptions();
                    if (gridOptions.enableAutoSizeColumns) {
                        this.sharedService.slickGrid.autosizeColumns();
                    }
                    break;
                case 'sort-asc':
                case 'sort-desc':
                    const isSortingAsc = (args.command === 'sort-asc');
                    this.sortColumn(event, args, isSortingAsc);
                    break;
                default:
                    break;
            }
        }
    }
    /** Sort the current column */
    sortColumn(event, args, isSortingAsc = true) {
        if (args === null || args === void 0 ? void 0 : args.column) {
            // get previously sorted columns
            const columnDef = args.column;
            // 1- get the sort columns without the current column, in the case of a single sort that would equal to an empty array
            const tmpSortedColumns = !this.sharedService.gridOptions.multiColumnSort ? [] : this.sortService.getCurrentColumnSorts(columnDef.id + '');
            let emitterType = EmitterType.local;
            // 2- add to the column array, the new sorted column by the header menu
            tmpSortedColumns.push({ columnId: columnDef.id, sortCol: columnDef, sortAsc: isSortingAsc });
            if (this.sharedService.gridOptions.backendServiceApi) {
                this.sortService.onBackendSortChanged(event, { multiColumnSort: true, sortCols: tmpSortedColumns, grid: this.sharedService.slickGrid });
                emitterType = EmitterType.remote;
            }
            else if (this.sharedService.dataView) {
                this.sortService.onLocalSortChanged(this.sharedService.slickGrid, tmpSortedColumns);
                emitterType = EmitterType.local;
            }
            else {
                // when using customDataView, we will simply send it as a onSort event with notify
                args.grid.onSort.notify(tmpSortedColumns);
            }
            // update the sharedService.slickGrid sortColumns array which will at the same add the visual sort icon(s) on the UI
            const newSortColumns = tmpSortedColumns.map(col => {
                var _a, _b, _c;
                return {
                    columnId: (_b = (_a = col === null || col === void 0 ? void 0 : col.sortCol) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : '',
                    sortAsc: (_c = col === null || col === void 0 ? void 0 : col.sortAsc) !== null && _c !== void 0 ? _c : true,
                };
            });
            // add sort icon in UI
            this.sharedService.slickGrid.setSortColumns(newSortColumns);
            // if we have an emitter type set, we will emit a sort changed
            // for the Grid State Service to see the change.
            // We also need to pass current sorters changed to the emitSortChanged method
            if (emitterType) {
                const currentLocalSorters = [];
                newSortColumns.forEach((sortCol) => {
                    currentLocalSorters.push({
                        columnId: `${sortCol.columnId}`,
                        direction: sortCol.sortAsc ? 'ASC' : 'DESC'
                    });
                });
                this.sortService.emitSortChanged(emitterType, currentLocalSorters);
            }
        }
    }
}
//# sourceMappingURL=headerMenuExtension.js.map