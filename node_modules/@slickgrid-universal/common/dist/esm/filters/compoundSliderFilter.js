import { Constants } from '../constants';
import { OperatorType } from '../enums/index';
import { buildSelectOperator } from './filterUtilities';
import { emptyElement, getTranslationPrefix, mapOperatorToShorthandDesignation, toSentenceCase } from '../services/utilities';
import { BindingEventService } from '../services/bindingEvent.service';
const DEFAULT_MIN_VALUE = 0;
const DEFAULT_MAX_VALUE = 100;
const DEFAULT_STEP = 1;
export class CompoundSliderFilter {
    constructor(translaterService) {
        this.translaterService = translaterService;
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
        this._elementRangeInputId = '';
        this._elementRangeOutputId = '';
        this.searchTerms = [];
        this._bindEventService = new BindingEventService();
    }
    /** Getter for the Filter Operator */
    get columnFilter() {
        return this.columnDef && this.columnDef.filter || {};
    }
    /** Getter to know what would be the default operator when none is specified */
    get defaultOperator() {
        return OperatorType.empty;
    }
    /** Getter for the Filter Generic Params */
    get filterParams() {
        return this.columnDef && this.columnDef.filter && this.columnDef.filter.params || {};
    }
    /** Getter for the `filter` properties */
    get filterProperties() {
        return this.columnDef && this.columnDef.filter || {};
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get gridOptions() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.grid) === null || _a === void 0 ? void 0 : _a.getOptions) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : {};
    }
    /** Getter for the single Locale texts provided by the user in main file or else use default English locales via the Constants */
    get locales() {
        return this.gridOptions.locales || Constants.locales;
    }
    /** Getter for the Filter Operator */
    get operator() {
        return this._operator || this.columnFilter.operator || this.defaultOperator;
    }
    /** Setter for the Filter Operator */
    set operator(op) {
        this._operator = op;
    }
    /**
     * Initialize the Filter
     */
    init(args) {
        var _a;
        if (!args) {
            throw new Error('[Slickgrid-Universal] A filter must always have an "init()" with valid arguments.');
        }
        this.grid = args.grid;
        this.callback = args.callback;
        this.columnDef = args.columnDef;
        this.operator = args.operator || '';
        this.searchTerms = (_a = args === null || args === void 0 ? void 0 : args.searchTerms) !== null && _a !== void 0 ? _a : [];
        // define the input & slider number IDs
        this._elementRangeInputId = `rangeInput_${this.columnDef.field}`;
        this._elementRangeOutputId = `rangeOutput_${this.columnDef.field}`;
        // filter input can only have 1 search term, so we will use the 1st array index if it exist
        const searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';
        // step 1, create the DOM Element of the filter which contain the compound Operator+Input
        // and initialize it if searchTerm is filled
        this.filterElm = this.createDomElement(searchTerm);
        // step 2, subscribe to the input change event and run the callback when that happens
        // also add/remove "filled" class for styling purposes
        this._bindEventService.bind(this.filterInputElm, 'change', this.onTriggerEvent.bind(this));
        this._bindEventService.bind(this.selectOperatorElm, 'change', this.onTriggerEvent.bind(this));
        // if user chose to display the slider number on the right side, then update it every time it changes
        // we need to use both "input" and "change" event to be all cross-browser
        if (!this.filterParams.hideSliderNumber) {
            this._bindEventService.bind(this.filterInputElm, ['input', 'change'], this.handleInputChange.bind(this));
        }
    }
    /**
     * Clear the filter value
     */
    clear(shouldTriggerQuery = true) {
        var _a, _b;
        if (this.filterElm && this.selectOperatorElm) {
            this._clearFilterTriggered = true;
            this._shouldTriggerQuery = shouldTriggerQuery;
            this.searchTerms = [];
            const clearedValue = (_b = (_a = this.filterParams) === null || _a === void 0 ? void 0 : _a.sliderStartValue) !== null && _b !== void 0 ? _b : DEFAULT_MIN_VALUE;
            this._currentValue = +clearedValue;
            this.selectOperatorElm.selectedIndex = 0;
            this.filterInputElm.value = clearedValue;
            if (this.filterNumberElm) {
                this.filterNumberElm.textContent = clearedValue;
            }
            this.onTriggerEvent(undefined);
            this.filterElm.classList.remove('filled');
        }
    }
    /**
     * destroy the filter
     */
    destroy() {
        var _a, _b, _c, _d;
        this._bindEventService.unbindAll();
        (_b = (_a = this.selectOperatorElm) === null || _a === void 0 ? void 0 : _a.remove) === null || _b === void 0 ? void 0 : _b.call(_a);
        emptyElement(this.filterElm);
        (_d = (_c = this.filterElm) === null || _c === void 0 ? void 0 : _c.remove) === null || _d === void 0 ? void 0 : _d.call(_c);
    }
    /**
     * Get selected value retrieved from the slider element
     * @params selected items
     */
    getValues() {
        return this._currentValue;
    }
    /** Set value(s) on the DOM element */
    setValues(values, operator) {
        const newValue = Array.isArray(values) ? values[0] : values;
        this._currentValue = +newValue;
        this.filterInputElm.value = `${newValue !== null && newValue !== void 0 ? newValue : ''}`;
        if (this.filterNumberElm) {
            this.filterNumberElm.textContent = `${newValue !== null && newValue !== void 0 ? newValue : ''}`;
        }
        // set the operator, in the DOM as well, when defined
        this.operator = operator || this.defaultOperator;
        if (operator && this.selectOperatorElm) {
            const operatorShorthand = mapOperatorToShorthandDesignation(this.operator);
            this.selectOperatorElm.value = operatorShorthand;
        }
    }
    //
    // protected functions
    // ------------------
    /** Get the available operator option values to populate the operator select dropdown list */
    getOperatorOptionValues() {
        var _a;
        if ((_a = this.columnFilter) === null || _a === void 0 ? void 0 : _a.compoundOperatorList) {
            return this.columnFilter.compoundOperatorList;
        }
        else {
            return [
                { operator: '', description: '' },
                { operator: '=', description: this.getOutputText('EQUAL_TO', 'TEXT_EQUAL_TO', 'Equal to') },
                { operator: '<', description: this.getOutputText('LESS_THAN', 'TEXT_LESS_THAN', 'Less than') },
                { operator: '<=', description: this.getOutputText('LESS_THAN_OR_EQUAL_TO', 'TEXT_LESS_THAN_OR_EQUAL_TO', 'Less than or equal to') },
                { operator: '>', description: this.getOutputText('GREATER_THAN', 'TEXT_GREATER_THAN', 'Greater than') },
                { operator: '>=', description: this.getOutputText('GREATER_THAN_OR_EQUAL_TO', 'TEXT_GREATER_THAN_OR_EQUAL_TO', 'Greater than or equal to') },
                { operator: '<>', description: this.getOutputText('NOT_EQUAL_TO', 'TEXT_NOT_EQUAL_TO', 'Not equal to') }
            ];
        }
    }
    /** Get Locale, Translated or a Default Text if first two aren't detected */
    getOutputText(translationKey, localeText, defaultText) {
        var _a, _b, _c, _d;
        if (((_a = this.gridOptions) === null || _a === void 0 ? void 0 : _a.enableTranslate) && ((_b = this.translaterService) === null || _b === void 0 ? void 0 : _b.translate)) {
            const translationPrefix = getTranslationPrefix(this.gridOptions);
            return this.translaterService.translate(`${translationPrefix}${translationKey}`);
        }
        return (_d = (_c = this.locales) === null || _c === void 0 ? void 0 : _c[localeText]) !== null && _d !== void 0 ? _d : defaultText;
    }
    /**
     * Create the DOM element
     */
    createDomElement(searchTerm) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const columnId = (_b = (_a = this.columnDef) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : '';
        const minValue = (_d = (_c = this.filterProperties) === null || _c === void 0 ? void 0 : _c.minValue) !== null && _d !== void 0 ? _d : DEFAULT_MIN_VALUE;
        const maxValue = (_f = (_e = this.filterProperties) === null || _e === void 0 ? void 0 : _e.maxValue) !== null && _f !== void 0 ? _f : DEFAULT_MAX_VALUE;
        const defaultValue = (_h = (_g = this.filterParams) === null || _g === void 0 ? void 0 : _g.sliderStartValue) !== null && _h !== void 0 ? _h : minValue;
        const step = (_k = (_j = this.filterProperties) === null || _j === void 0 ? void 0 : _j.valueStep) !== null && _k !== void 0 ? _k : DEFAULT_STEP;
        const startValue = +((_m = (_l = this.filterParams) === null || _l === void 0 ? void 0 : _l.sliderStartValue) !== null && _m !== void 0 ? _m : minValue);
        const headerElm = this.grid.getHeaderRowColumn(this.columnDef.id);
        emptyElement(headerElm);
        let searchTermInput = (searchTerm || '0');
        if (+searchTermInput < minValue) {
            searchTermInput = `${minValue}`;
        }
        if (+searchTermInput < startValue) {
            searchTermInput = `${startValue}`;
        }
        this._currentValue = +searchTermInput;
        /*
          Full DOM Element Template::
          <div class="form-group search-filter slider-container filter-${columnId}" data-columnid="${columnId}">
            <div class="input-group search-filter filter-${columnId}">
              <span class="input-group-addon input-group-prepend operator">
                <select class="form-control"><option value="">...</select>
              </span>
              <input type="range" class="form-control slider-filter-input range compound-slider ${this._elementRangeInputId}" value="0" min="0" max="100" step="1" name="${this._elementRangeInputId}"/>
              <div class="input-group-addon input-group-append slider-value">
                <span class="input-group-text rangeOutput_${columnId}">0</span>
              </div>
            </div>
          </div>
        */
        // create the DOM Select dropdown for the Operator
        this.selectOperatorElm = buildSelectOperator(this.getOperatorOptionValues());
        const spanPrependElm = document.createElement('span');
        spanPrependElm.className = 'input-group-addon input-group-prepend operator';
        spanPrependElm.appendChild(this.selectOperatorElm);
        // create the DOM element
        this.filterInputElm = document.createElement('input');
        this.filterInputElm.type = 'range';
        this.filterInputElm.className = `form-control slider-filter-input range compound-slider ${this._elementRangeInputId}`;
        this.filterInputElm.defaultValue = defaultValue;
        this.filterInputElm.value = searchTermInput;
        this.filterInputElm.min = `${minValue}`;
        this.filterInputElm.max = `${maxValue}`;
        this.filterInputElm.step = `${step}`;
        this.filterInputElm.name = this._elementRangeInputId;
        this.filterInputElm.setAttribute('aria-label', (_p = (_o = this.columnFilter) === null || _o === void 0 ? void 0 : _o.ariaLabel) !== null && _p !== void 0 ? _p : `${toSentenceCase(columnId + '')} Search Filter`);
        const divContainerFilterElm = document.createElement('div');
        divContainerFilterElm.className = `form-group search-filter slider-container filter-${columnId}`;
        this.containerInputGroupElm = document.createElement('div');
        this.containerInputGroupElm.className = `input-group search-filter filter-${columnId}`;
        this.containerInputGroupElm.appendChild(spanPrependElm);
        this.containerInputGroupElm.appendChild(this.filterInputElm);
        divContainerFilterElm.appendChild(this.containerInputGroupElm);
        if (!this.filterParams.hideSliderNumber) {
            this.containerInputGroupElm.classList.add('input-group');
            this.filterInputElm.value = searchTermInput;
            const divGroupAppendElm = document.createElement('div');
            divGroupAppendElm.className = 'input-group-addon input-group-append slider-value';
            this.filterNumberElm = document.createElement('span');
            this.filterNumberElm.className = `input-group-text ${this._elementRangeOutputId}`;
            this.filterNumberElm.textContent = searchTermInput;
            divGroupAppendElm.appendChild(this.filterNumberElm);
            this.containerInputGroupElm.appendChild(divGroupAppendElm);
        }
        divContainerFilterElm.dataset.columnid = `${columnId}`;
        if (this.operator) {
            const operatorShorthand = mapOperatorToShorthandDesignation(this.operator);
            this.selectOperatorElm.value = operatorShorthand;
        }
        // if there's a search term, we will add the "filled" class for styling purposes
        if (searchTerm) {
            divContainerFilterElm.classList.add('filled');
        }
        // append the new DOM element to the header row
        headerElm.appendChild(divContainerFilterElm);
        return divContainerFilterElm;
    }
    handleInputChange(event) {
        const value = (event === null || event === void 0 ? void 0 : event.target).value;
        if (value !== undefined && value !== null) {
            const element = document.querySelector(`.${this._elementRangeOutputId || ''}`);
            if (element === null || element === void 0 ? void 0 : element.textContent) {
                element.textContent = value;
            }
        }
    }
    onTriggerEvent(e) {
        const value = this.filterInputElm.value;
        this._currentValue = +value;
        if (this._clearFilterTriggered) {
            this.filterElm.classList.remove('filled');
            this.callback(e, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });
        }
        else {
            this.filterElm.classList.add('filled');
            const selectedOperator = this.selectOperatorElm.value;
            this.callback(e, { columnDef: this.columnDef, searchTerms: (value ? [value || '0'] : null), operator: selectedOperator || '', shouldTriggerQuery: this._shouldTriggerQuery });
        }
        // reset both flags for next use
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
    }
}
//# sourceMappingURL=compoundSliderFilter.js.map