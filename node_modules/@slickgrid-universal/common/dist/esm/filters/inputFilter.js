import { OperatorType } from '../enums/index';
import { BindingEventService } from '../services/bindingEvent.service';
import { emptyElement, toSentenceCase } from '../services';
export class InputFilter {
    constructor() {
        this._clearFilterTriggered = false;
        this._debounceTypingDelay = 0;
        this._shouldTriggerQuery = true;
        this._inputType = 'text';
        this.searchTerms = [];
        this._bindEventService = new BindingEventService();
    }
    /** Getter for the Column Filter */
    get columnFilter() {
        return this.columnDef && this.columnDef.filter || {};
    }
    /** Getter to know what would be the default operator when none is specified */
    get defaultOperator() {
        return OperatorType.empty;
    }
    /** Getter of input type (text, number, password) */
    get inputType() {
        return this._inputType;
    }
    /** Setter of input type (text, number, password) */
    set inputType(type) {
        this._inputType = type;
    }
    /** Getter of the Operator to use when doing the filter comparing */
    get operator() {
        var _a, _b;
        return (_b = (_a = this.columnFilter) === null || _a === void 0 ? void 0 : _a.operator) !== null && _b !== void 0 ? _b : this.defaultOperator;
    }
    /** Setter for the filter operator */
    set operator(operator) {
        if (this.columnFilter) {
            this.columnFilter.operator = operator;
        }
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get gridOptions() {
        return (this.grid && this.grid.getOptions) ? this.grid.getOptions() : {};
    }
    /**
     * Initialize the Filter
     */
    init(args) {
        var _a, _b, _c, _d, _e;
        if (!args) {
            throw new Error('[Slickgrid-Universal] A filter must always have an "init()" with valid arguments.');
        }
        this.grid = args.grid;
        this.callback = args.callback;
        this.columnDef = args.columnDef;
        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
        // analyze if we have any keyboard debounce delay (do we wait for user to finish typing before querying)
        // it is used by default for a backend service but is optional when using local dataset
        const backendApi = (_a = this.gridOptions) === null || _a === void 0 ? void 0 : _a.backendServiceApi;
        this._debounceTypingDelay = (_e = (backendApi ? ((_b = backendApi === null || backendApi === void 0 ? void 0 : backendApi.filterTypingDebounce) !== null && _b !== void 0 ? _b : (_c = this.gridOptions) === null || _c === void 0 ? void 0 : _c.defaultBackendServiceFilterTypingDebounce) : (_d = this.gridOptions) === null || _d === void 0 ? void 0 : _d.filterTypingDebounce)) !== null && _e !== void 0 ? _e : 0;
        // filter input can only have 1 search term, so we will use the 1st array index if it exist
        const searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';
        // step 1, create the DOM Element of the filter & initialize it if searchTerm is filled
        this._filterElm = this.createDomElement(searchTerm);
        // step 2, subscribe to the input event and run the callback when that happens
        // also add/remove "filled" class for styling purposes
        // we'll use all necessary events to cover the following (keyup, change, mousewheel & spinner)
        this._bindEventService.bind(this._filterElm, ['keyup', 'blur', 'change', 'wheel'], this.handleInputChange.bind(this));
    }
    /**
     * Clear the filter value
     */
    clear(shouldTriggerQuery = true) {
        if (this._filterElm) {
            this._clearFilterTriggered = true;
            this._shouldTriggerQuery = shouldTriggerQuery;
            this.searchTerms = [];
            this._filterElm.value = '';
            this._filterElm.dispatchEvent(new Event('change'));
        }
    }
    /**
     * destroy the filter
     */
    destroy() {
        var _a, _b;
        this._bindEventService.unbindAll();
        (_b = (_a = this._filterElm) === null || _a === void 0 ? void 0 : _a.remove) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    getValue() {
        return this._filterElm.value;
    }
    /** Set value(s) on the DOM element */
    setValues(values, operator) {
        const searchValues = Array.isArray(values) ? values : [values];
        let searchValue = '';
        for (const value of searchValues) {
            searchValue = operator ? this.addOptionalOperatorIntoSearchString(value, operator) : value;
            this._filterElm.value = `${searchValue !== null && searchValue !== void 0 ? searchValue : ''}`;
        }
        // set the operator when defined
        this.operator = operator || this.defaultOperator;
    }
    //
    // protected functions
    // ------------------
    /**
     * When loading the search string from the outside into the input text field, we should also add the prefix/suffix of the operator.
     * We do this so that if it was loaded by a Grid Presets then we should also add the operator into the search string
     * Let's take these 3 examples:
     * 1. (operator: '>=', searchTerms:[55]) should display as ">=55"
     * 2. (operator: 'StartsWith', searchTerms:['John']) should display as "John*"
     * 3. (operator: 'EndsWith', searchTerms:['John']) should display as "*John"
     * @param operator - operator string
     */
    addOptionalOperatorIntoSearchString(inputValue, operator) {
        let searchTermPrefix = '';
        let searchTermSuffix = '';
        let outputValue = inputValue === undefined || inputValue === null ? '' : `${inputValue}`;
        if (operator && outputValue) {
            switch (operator) {
                case '<>':
                case '!=':
                case '=':
                case '==':
                case '>':
                case '>=':
                case '<':
                case '<=':
                    searchTermPrefix = operator;
                    break;
                case 'EndsWith':
                case '*z':
                    searchTermPrefix = '*';
                    break;
                case 'StartsWith':
                case 'a*':
                    searchTermSuffix = '*';
                    break;
            }
            outputValue = `${searchTermPrefix}${outputValue}${searchTermSuffix}`;
        }
        return outputValue;
    }
    /**
     * From the html template string, create a DOM element
     * @param {Object} searchTerm - filter search term
     * @returns {Object} DOM element filter
     */
    createDomElement(searchTerm) {
        var _a, _b, _c, _d, _e, _f, _g;
        const columnId = (_b = (_a = this.columnDef) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : '';
        const headerElm = this.grid.getHeaderRowColumn(columnId);
        emptyElement(headerElm);
        // create the DOM element & add an ID and filter class
        let placeholder = (_d = (_c = this.gridOptions) === null || _c === void 0 ? void 0 : _c.defaultFilterPlaceholder) !== null && _d !== void 0 ? _d : '';
        if ((_e = this.columnFilter) === null || _e === void 0 ? void 0 : _e.placeholder) {
            placeholder = this.columnFilter.placeholder;
        }
        const inputElm = document.createElement('input');
        inputElm.type = this._inputType || 'text';
        inputElm.className = `form-control search-filter filter-${columnId}`;
        inputElm.autocomplete = 'off';
        inputElm.placeholder = placeholder;
        inputElm.setAttribute('aria-label', (_g = (_f = this.columnFilter) === null || _f === void 0 ? void 0 : _f.ariaLabel) !== null && _g !== void 0 ? _g : `${toSentenceCase(columnId + '')} Search Filter`);
        inputElm.setAttribute('role', 'presentation');
        inputElm.value = (searchTerm !== null && searchTerm !== void 0 ? searchTerm : '');
        inputElm.dataset.columnid = `${columnId}`;
        // if there's a search term, we will add the "filled" class for styling purposes
        if (searchTerm) {
            inputElm.classList.add('filled');
        }
        // append the new DOM element to the header row & an empty span
        headerElm.appendChild(inputElm);
        headerElm.appendChild(document.createElement('span'));
        return inputElm;
    }
    /**
     * Event handler to cover the following (keyup, change, mousewheel & spinner)
     * We will trigger the Filter Service callback from this handler
     */
    handleInputChange(event) {
        var _a, _b, _c, _d;
        if (this._clearFilterTriggered) {
            this.callback(event, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });
            this._filterElm.classList.remove('filled');
        }
        else {
            const eventType = (_a = event === null || event === void 0 ? void 0 : event.type) !== null && _a !== void 0 ? _a : '';
            let value = (_c = (_b = event === null || event === void 0 ? void 0 : event.target) === null || _b === void 0 ? void 0 : _b.value) !== null && _c !== void 0 ? _c : '';
            const enableWhiteSpaceTrim = this.gridOptions.enableFilterTrimWhiteSpace || this.columnFilter.enableTrimWhiteSpace;
            if (typeof value === 'string' && enableWhiteSpaceTrim) {
                value = value.trim();
            }
            value === '' ? this._filterElm.classList.remove('filled') : this._filterElm.classList.add('filled');
            const callbackArgs = { columnDef: this.columnDef, operator: this.operator, searchTerms: [value], shouldTriggerQuery: this._shouldTriggerQuery };
            const typingDelay = (eventType === 'keyup' && ((_d = event) === null || _d === void 0 ? void 0 : _d.key) !== 'Enter') ? this._debounceTypingDelay : 0;
            if (typingDelay > 0) {
                clearTimeout(this._timer);
                this._timer = setTimeout(() => this.callback(event, callbackArgs), typingDelay);
            }
            else {
                this.callback(event, callbackArgs);
            }
        }
        // reset both flags for next use
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
    }
}
//# sourceMappingURL=inputFilter.js.map