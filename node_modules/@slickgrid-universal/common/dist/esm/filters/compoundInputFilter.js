import { Constants } from '../constants';
import { FieldType, OperatorType, } from '../enums/index';
import { buildSelectOperator } from './filterUtilities';
import { emptyElement, getTranslationPrefix, mapOperatorToShorthandDesignation, toSentenceCase } from '../services/utilities';
import { BindingEventService } from '../services/bindingEvent.service';
export class CompoundInputFilter {
    constructor(translaterService) {
        this.translaterService = translaterService;
        this._clearFilterTriggered = false;
        this._debounceTypingDelay = 0;
        this._shouldTriggerQuery = true;
        this._inputType = 'text';
        this.searchTerms = [];
        this._bindEventService = new BindingEventService();
    }
    /** Getter for the Grid Options pulled through the Grid Object */
    get gridOptions() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.grid) === null || _a === void 0 ? void 0 : _a.getOptions) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : {};
    }
    /** Getter for the Column Filter */
    get columnFilter() {
        var _a, _b;
        return (_b = (_a = this.columnDef) === null || _a === void 0 ? void 0 : _a.filter) !== null && _b !== void 0 ? _b : {};
    }
    /** Getter to know what would be the default operator when none is specified */
    get defaultOperator() {
        return OperatorType.empty;
    }
    /** Getter of input type (text, number, password) */
    get inputType() {
        return this._inputType;
    }
    /** Setter of input type (text, number, password) */
    set inputType(type) {
        this._inputType = type;
    }
    /** Getter for the single Locale texts provided by the user in main file or else use default English locales via the Constants */
    get locales() {
        return this.gridOptions.locales || Constants.locales;
    }
    /** Getter of the Operator to use when doing the filter comparing */
    get operator() {
        return this._operator || this.defaultOperator;
    }
    /** Setter of the Operator to use when doing the filter comparing */
    set operator(op) {
        this._operator = op;
    }
    /**
     * Initialize the Filter
     */
    init(args) {
        var _a, _b, _c, _d, _e;
        if (!args) {
            throw new Error('[Slickgrid-Universal] A filter must always have an "init()" with valid arguments.');
        }
        this.grid = args.grid;
        this.callback = args.callback;
        this.columnDef = args.columnDef;
        this.operator = args.operator;
        this.searchTerms = (args.hasOwnProperty('searchTerms') ? args.searchTerms : []) || [];
        // analyze if we have any keyboard debounce delay (do we wait for user to finish typing before querying)
        // it is used by default for a backend service but is optional when using local dataset
        const backendApi = (_a = this.gridOptions) === null || _a === void 0 ? void 0 : _a.backendServiceApi;
        this._debounceTypingDelay = (_e = (backendApi ? ((_b = backendApi === null || backendApi === void 0 ? void 0 : backendApi.filterTypingDebounce) !== null && _b !== void 0 ? _b : (_c = this.gridOptions) === null || _c === void 0 ? void 0 : _c.defaultBackendServiceFilterTypingDebounce) : (_d = this.gridOptions) === null || _d === void 0 ? void 0 : _d.filterTypingDebounce)) !== null && _e !== void 0 ? _e : 0;
        // filter input can only have 1 search term, so we will use the 1st array index if it exist
        const searchTerm = (Array.isArray(this.searchTerms) && this.searchTerms.length >= 0) ? this.searchTerms[0] : '';
        // step 1, create the DOM Element of the filter which contain the compound Operator+Input
        // and initialize it if searchTerm is filled
        this._filterElm = this.createDomElement(searchTerm);
        // step 3, subscribe to the keyup event and run the callback when that happens
        // also add/remove "filled" class for styling purposes
        // we'll use all necessary events to cover the following (keyup, change, mousewheel & spinner)
        this._bindEventService.bind(this._filterInputElm, ['keyup', 'blur', 'change', 'wheel'], this.onTriggerEvent.bind(this));
        this._bindEventService.bind(this._selectOperatorElm, 'change', this.onTriggerEvent.bind(this));
    }
    /**
     * Clear the filter value
     */
    clear(shouldTriggerQuery = true) {
        if (this._filterElm && this._selectOperatorElm) {
            this._clearFilterTriggered = true;
            this._shouldTriggerQuery = shouldTriggerQuery;
            this.searchTerms = [];
            this._selectOperatorElm.selectedIndex = 0;
            this._filterInputElm.value = '';
            this.onTriggerEvent(undefined);
        }
    }
    /**
     * destroy the filter
     */
    destroy() {
        var _a, _b, _c, _d;
        this._bindEventService.unbindAll();
        (_b = (_a = this._selectOperatorElm) === null || _a === void 0 ? void 0 : _a.remove) === null || _b === void 0 ? void 0 : _b.call(_a);
        (_d = (_c = this._filterElm) === null || _c === void 0 ? void 0 : _c.remove) === null || _d === void 0 ? void 0 : _d.call(_c);
    }
    /** Set value(s) on the DOM element */
    setValues(values, operator) {
        if (values) {
            const newValue = Array.isArray(values) ? values[0] : values;
            this._filterInputElm.value = `${newValue !== null && newValue !== void 0 ? newValue : ''}`;
        }
        // set the operator, in the DOM as well, when defined
        this.operator = operator || this.defaultOperator;
        if (operator && this._selectOperatorElm) {
            const operatorShorthand = mapOperatorToShorthandDesignation(this.operator);
            this._selectOperatorElm.value = operatorShorthand;
        }
    }
    //
    // protected functions
    // ------------------
    buildInputElement() {
        var _a, _b, _c, _d, _e, _f, _g;
        const columnId = (_b = (_a = this.columnDef) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : '';
        // create the DOM element & add an ID and filter class
        let placeholder = (_d = (_c = this.gridOptions) === null || _c === void 0 ? void 0 : _c.defaultFilterPlaceholder) !== null && _d !== void 0 ? _d : '';
        if ((_e = this.columnFilter) === null || _e === void 0 ? void 0 : _e.placeholder) {
            placeholder = this.columnFilter.placeholder;
        }
        const inputElm = document.createElement('input');
        inputElm.type = this._inputType || 'text';
        inputElm.className = `form-control compound-input filter-${columnId}`;
        inputElm.autocomplete = 'off';
        inputElm.placeholder = placeholder;
        inputElm.setAttribute('role', 'presentation');
        inputElm.setAttribute('aria-label', (_g = (_f = this.columnFilter) === null || _f === void 0 ? void 0 : _f.ariaLabel) !== null && _g !== void 0 ? _g : `${toSentenceCase(columnId + '')} Search Filter`);
        return inputElm;
    }
    /** Get the available operator option values to populate the operator select dropdown list */
    getOperatorOptionValues() {
        var _a;
        const type = (this.columnDef.type && this.columnDef.type) ? this.columnDef.type : FieldType.string;
        let optionValues = [];
        if ((_a = this.columnFilter) === null || _a === void 0 ? void 0 : _a.compoundOperatorList) {
            return this.columnFilter.compoundOperatorList;
        }
        else {
            switch (type) {
                case FieldType.string:
                case FieldType.text:
                case FieldType.readonly:
                case FieldType.password:
                    optionValues = [
                        { operator: '', description: this.getOutputText('CONTAINS', 'TEXT_CONTAINS', 'Contains') },
                        { operator: '<>', description: this.getOutputText('NOT_CONTAINS', 'TEXT_NOT_CONTAINS', 'Not Contains') },
                        { operator: '=', description: this.getOutputText('EQUALS', 'TEXT_EQUALS', 'Equals') },
                        { operator: '!=', description: this.getOutputText('NOT_EQUAL_TO', 'TEXT_NOT_EQUAL_TO', 'Not equal to') },
                        { operator: 'a*', description: this.getOutputText('STARTS_WITH', 'TEXT_STARTS_WITH', 'Starts with') },
                        { operator: '*z', description: this.getOutputText('ENDS_WITH', 'TEXT_ENDS_WITH', 'Ends with') },
                    ];
                    break;
                default:
                    optionValues = [
                        { operator: '', description: '' },
                        { operator: '=', description: this.getOutputText('EQUAL_TO', 'TEXT_EQUAL_TO', 'Equal to') },
                        { operator: '<', description: this.getOutputText('LESS_THAN', 'TEXT_LESS_THAN', 'Less than') },
                        { operator: '<=', description: this.getOutputText('LESS_THAN_OR_EQUAL_TO', 'TEXT_LESS_THAN_OR_EQUAL_TO', 'Less than or equal to') },
                        { operator: '>', description: this.getOutputText('GREATER_THAN', 'TEXT_GREATER_THAN', 'Greater than') },
                        { operator: '>=', description: this.getOutputText('GREATER_THAN_OR_EQUAL_TO', 'TEXT_GREATER_THAN_OR_EQUAL_TO', 'Greater than or equal to') },
                        { operator: '<>', description: this.getOutputText('NOT_EQUAL_TO', 'TEXT_NOT_EQUAL_TO', 'Not equal to') }
                    ];
                    break;
            }
        }
        return optionValues;
    }
    /** Get Locale, Translated or a Default Text if first two aren't detected */
    getOutputText(translationKey, localeText, defaultText) {
        var _a, _b, _c, _d;
        if (((_a = this.gridOptions) === null || _a === void 0 ? void 0 : _a.enableTranslate) && ((_b = this.translaterService) === null || _b === void 0 ? void 0 : _b.translate)) {
            const translationPrefix = getTranslationPrefix(this.gridOptions);
            return this.translaterService.translate(`${translationPrefix}${translationKey}`);
        }
        return (_d = (_c = this.locales) === null || _c === void 0 ? void 0 : _c[localeText]) !== null && _d !== void 0 ? _d : defaultText;
    }
    /**
     * Create the DOM element
     */
    createDomElement(searchTerm) {
        var _a, _b;
        const columnId = (_b = (_a = this.columnDef) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : '';
        const headerElm = this.grid.getHeaderRowColumn(columnId);
        emptyElement(headerElm);
        // create the DOM Select dropdown for the Operator
        this._selectOperatorElm = buildSelectOperator(this.getOperatorOptionValues());
        this._filterInputElm = this.buildInputElement();
        const emptySpanElm = document.createElement('span');
        const filterContainerElm = document.createElement('div');
        filterContainerElm.className = `form-group search-filter filter-${columnId}`;
        const containerInputGroupElm = document.createElement('div');
        containerInputGroupElm.className = 'input-group';
        const operatorInputGroupAddonElm = document.createElement('div');
        operatorInputGroupAddonElm.className = 'input-group-addon input-group-prepend operator';
        /* the DOM element final structure will be
          <div class="input-group">
            <div class="input-group-addon input-group-prepend operator">
              <select class="form-control"></select>
            </div>
            <input class="form-control compound-input" type="text" />
          </div>
        */
        operatorInputGroupAddonElm.appendChild(this._selectOperatorElm);
        containerInputGroupElm.appendChild(operatorInputGroupAddonElm);
        containerInputGroupElm.appendChild(this._filterInputElm);
        containerInputGroupElm.appendChild(emptySpanElm);
        // create the DOM element & add an ID and filter class
        filterContainerElm.appendChild(containerInputGroupElm);
        this._filterInputElm.value = `${searchTerm !== null && searchTerm !== void 0 ? searchTerm : ''}`;
        this._filterInputElm.dataset.columnid = `${columnId}`;
        if (this.operator) {
            const operatorShorthand = mapOperatorToShorthandDesignation(this.operator);
            this._selectOperatorElm.value = operatorShorthand;
        }
        // if there's a search term, we will add the "filled" class for styling purposes
        if (searchTerm) {
            this._filterInputElm.classList.add('filled');
        }
        // append the new DOM element to the header row
        if (filterContainerElm) {
            headerElm.appendChild(filterContainerElm);
        }
        return filterContainerElm;
    }
    /**
     * Event trigger, could be called by the Operator dropdown or the input itself and we will cover the following (keyup, change, mousewheel & spinner)
     * We will trigger the Filter Service callback from this handler
     */
    onTriggerEvent(event) {
        var _a, _b;
        if (this._clearFilterTriggered) {
            this.callback(event, { columnDef: this.columnDef, clearFilterTriggered: this._clearFilterTriggered, shouldTriggerQuery: this._shouldTriggerQuery });
            this._filterElm.classList.remove('filled');
        }
        else {
            const eventType = (_a = event === null || event === void 0 ? void 0 : event.type) !== null && _a !== void 0 ? _a : '';
            const selectedOperator = this._selectOperatorElm.value;
            let value = this._filterInputElm.value;
            const enableWhiteSpaceTrim = this.gridOptions.enableFilterTrimWhiteSpace || this.columnFilter.enableTrimWhiteSpace;
            if (typeof value === 'string' && enableWhiteSpaceTrim) {
                value = value.trim();
            }
            (value !== null && value !== undefined && value !== '') ? this._filterElm.classList.add('filled') : this._filterElm.classList.remove('filled');
            const callbackArgs = { columnDef: this.columnDef, searchTerms: (value ? [value] : null), operator: selectedOperator, shouldTriggerQuery: this._shouldTriggerQuery };
            const typingDelay = (eventType === 'keyup' && ((_b = event) === null || _b === void 0 ? void 0 : _b.key) !== 'Enter') ? this._debounceTypingDelay : 0;
            if (typingDelay > 0) {
                clearTimeout(this.timer);
                this.timer = setTimeout(() => this.callback(event, callbackArgs), typingDelay);
            }
            else {
                this.callback(event, callbackArgs);
            }
        }
        // reset both flags for next use
        this._clearFilterTriggered = false;
        this._shouldTriggerQuery = true;
    }
}
//# sourceMappingURL=compoundInputFilter.js.map