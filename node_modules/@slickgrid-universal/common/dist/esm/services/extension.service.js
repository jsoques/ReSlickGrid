// import common 3rd party SlickGrid plugins/libs
import 'slickgrid/plugins/slick.cellrangedecorator';
import 'slickgrid/plugins/slick.cellrangeselector';
import 'slickgrid/plugins/slick.cellselectionmodel';
import { ExtensionName } from '../enums/index';
export class ExtensionService {
    constructor(autoTooltipExtension, cellExternalCopyExtension, cellMenuExtension, checkboxSelectorExtension, columnPickerExtension, contextMenuExtension, draggableGroupingExtension, gridMenuExtension, groupItemMetaExtension, headerButtonExtension, headerMenuExtension, rowDetailViewExtension, rowMoveManagerExtension, rowSelectionExtension, sharedService, translaterService) {
        this.autoTooltipExtension = autoTooltipExtension;
        this.cellExternalCopyExtension = cellExternalCopyExtension;
        this.cellMenuExtension = cellMenuExtension;
        this.checkboxSelectorExtension = checkboxSelectorExtension;
        this.columnPickerExtension = columnPickerExtension;
        this.contextMenuExtension = contextMenuExtension;
        this.draggableGroupingExtension = draggableGroupingExtension;
        this.gridMenuExtension = gridMenuExtension;
        this.groupItemMetaExtension = groupItemMetaExtension;
        this.headerButtonExtension = headerButtonExtension;
        this.headerMenuExtension = headerMenuExtension;
        this.rowDetailViewExtension = rowDetailViewExtension;
        this.rowMoveManagerExtension = rowMoveManagerExtension;
        this.rowSelectionExtension = rowSelectionExtension;
        this.sharedService = sharedService;
        this.translaterService = translaterService;
        this._extensionCreatedList = {};
        this._extensionList = {};
    }
    get extensionList() {
        return this._extensionList;
    }
    /** Dispose of all the controls & plugins */
    dispose() {
        var _a;
        this.sharedService.visibleColumns = [];
        // dispose of each control/plugin & reset the list
        for (const extensionName of Object.keys(this._extensionList)) {
            if (this._extensionList.hasOwnProperty(extensionName)) {
                const extension = this._extensionList[extensionName];
                if ((_a = extension === null || extension === void 0 ? void 0 : extension.class) === null || _a === void 0 ? void 0 : _a.dispose) {
                    extension.class.dispose();
                }
            }
        }
        for (const key of Object.keys(this._extensionList)) {
            delete this._extensionList[key];
        }
    }
    /** Get all columns (includes visible and non-visible) */
    getAllColumns() {
        return this.sharedService.allColumns || [];
    }
    /** Get only visible columns */
    getVisibleColumns() {
        return this.sharedService.visibleColumns || [];
    }
    /**
     * Get an Extension by it's name
     *  @param name
     */
    getExtensionByName(name) {
        if (this._extensionList && this._extensionList[name]) {
            return this._extensionList[name];
        }
        return undefined;
    }
    /**
     * Get the instance of the SlickGrid addon (control or plugin).
     * This is the raw addon coming directly from SlickGrid itself, not to confuse with Slickgrid-Universal extension
     *  @param name
     */
    getSlickgridAddonInstance(name) {
        const extension = this.getExtensionByName(name);
        if (extension && extension.class && (extension.instance)) {
            if (extension.class && extension.class.getAddonInstance) {
                return extension.class.getAddonInstance();
            }
            return extension.instance;
        }
        return null;
    }
    /** Auto-resize all the column in the grid to fit the grid width */
    autoResizeColumns() {
        this.sharedService.slickGrid.autosizeColumns();
    }
    /** Bind/Create different Controls or Plugins after the Grid is created */
    bindDifferentExtensions() {
        if (this.sharedService && this.sharedService.gridOptions) {
            // make sure all columns are translated before creating ColumnPicker/GridMenu Controls
            // this is to avoid having hidden columns not being translated on first load
            if (this.sharedService.gridOptions.enableTranslate) {
                this.translateItems(this.sharedService.allColumns, 'nameKey', 'name');
            }
            // Auto Tooltip Plugin
            if (this.sharedService.gridOptions.enableAutoTooltip && this.autoTooltipExtension && this.autoTooltipExtension.register) {
                const instance = this.autoTooltipExtension.register();
                if (instance) {
                    this._extensionList[ExtensionName.autoTooltip] = { name: ExtensionName.autoTooltip, class: this.autoTooltipExtension, instance };
                }
            }
            // Cell External Copy Manager Plugin (Excel Like)
            if (this.sharedService.gridOptions.enableExcelCopyBuffer && this.cellExternalCopyExtension && this.cellExternalCopyExtension.register) {
                const instance = this.cellExternalCopyExtension.register();
                if (instance) {
                    this._extensionList[ExtensionName.cellExternalCopyManager] = { name: ExtensionName.cellExternalCopyManager, class: this.cellExternalCopyExtension, instance };
                }
            }
            // (Action) Cell Menu Plugin
            if (this.sharedService.gridOptions.enableCellMenu && this.cellMenuExtension && this.cellMenuExtension.register) {
                const instance = this.cellMenuExtension.register();
                if (instance) {
                    this._extensionList[ExtensionName.cellMenu] = { name: ExtensionName.cellMenu, class: this.cellMenuExtension, instance };
                }
            }
            // Row Selection Plugin
            // this extension should be registered BEFORE the CheckboxSelector, RowDetail or RowMoveManager since it can be use by these 2 plugins
            if (!this.getExtensionByName(ExtensionName.rowSelection) && (this.sharedService.gridOptions.enableRowSelection || this.sharedService.gridOptions.enableCheckboxSelector || this.sharedService.gridOptions.enableRowDetailView || this.sharedService.gridOptions.enableRowMoveManager)) {
                if (this.rowSelectionExtension && this.rowSelectionExtension.register) {
                    const instance = this.rowSelectionExtension.register();
                    if (instance) {
                        this._extensionList[ExtensionName.rowSelection] = { name: ExtensionName.rowSelection, class: this.rowSelectionExtension, instance };
                    }
                }
            }
            // Checkbox Selector Plugin
            if (this.sharedService.gridOptions.enableCheckboxSelector && this.checkboxSelectorExtension && this.checkboxSelectorExtension.register) {
                const rowSelectionExtension = this.getExtensionByName(ExtensionName.rowSelection);
                this.checkboxSelectorExtension.register(rowSelectionExtension === null || rowSelectionExtension === void 0 ? void 0 : rowSelectionExtension.instance);
                const createdExtension = this.getCreatedExtensionByName(ExtensionName.checkboxSelector); // get the instance from when it was really created earlier
                const instance = createdExtension && createdExtension.instance;
                if (instance) {
                    this._extensionList[ExtensionName.checkboxSelector] = { name: ExtensionName.checkboxSelector, class: this.checkboxSelectorExtension, instance };
                }
            }
            // Column Picker Control
            if (this.sharedService.gridOptions.enableColumnPicker && this.columnPickerExtension && this.columnPickerExtension.register) {
                const instance = this.columnPickerExtension.register();
                if (instance) {
                    this._extensionList[ExtensionName.columnPicker] = { name: ExtensionName.columnPicker, class: this.columnPickerExtension, instance };
                }
            }
            // Context Menu Control
            if (this.sharedService.gridOptions.enableContextMenu && this.contextMenuExtension && this.contextMenuExtension.register) {
                const instance = this.contextMenuExtension.register();
                if (instance) {
                    this._extensionList[ExtensionName.contextMenu] = { name: ExtensionName.contextMenu, class: this.contextMenuExtension, instance };
                }
            }
            // Draggable Grouping Plugin
            if (this.sharedService.gridOptions.enableDraggableGrouping && this.draggableGroupingExtension && this.draggableGroupingExtension.register) {
                const instance = this.draggableGroupingExtension.register();
                if (instance) {
                    this._extensionList[ExtensionName.draggableGrouping] = { name: ExtensionName.draggableGrouping, class: this.draggableGroupingExtension, instance };
                }
            }
            // Grid Menu Control
            if (this.sharedService.gridOptions.enableGridMenu && this.gridMenuExtension && this.gridMenuExtension.register) {
                const instance = this.gridMenuExtension.register();
                if (instance) {
                    this._extensionList[ExtensionName.gridMenu] = { name: ExtensionName.gridMenu, class: this.gridMenuExtension, instance };
                }
            }
            // Grouping Plugin
            // register the group item metadata provider to add expand/collapse group handlers
            if (this.sharedService.gridOptions.enableDraggableGrouping || this.sharedService.gridOptions.enableGrouping) {
                if (this.groupItemMetaExtension && this.groupItemMetaExtension.register) {
                    const instance = this.groupItemMetaExtension.register();
                    if (instance) {
                        this._extensionList[ExtensionName.groupItemMetaProvider] = { name: ExtensionName.groupItemMetaProvider, class: this.groupItemMetaExtension, instance };
                    }
                }
            }
            // Header Button Plugin
            if (this.sharedService.gridOptions.enableHeaderButton && this.headerButtonExtension && this.headerButtonExtension.register) {
                const instance = this.headerButtonExtension.register();
                if (instance) {
                    this._extensionList[ExtensionName.headerButton] = { name: ExtensionName.headerButton, class: this.headerButtonExtension, instance };
                }
            }
            // Header Menu Plugin
            if (this.sharedService.gridOptions.enableHeaderMenu && this.headerMenuExtension && this.headerMenuExtension.register) {
                const instance = this.headerMenuExtension.register();
                if (instance) {
                    this._extensionList[ExtensionName.headerMenu] = { name: ExtensionName.headerMenu, class: this.headerMenuExtension, instance };
                }
            }
            // Row Detail View Plugin
            if (this.sharedService.gridOptions.enableRowDetailView) {
                if (this.rowDetailViewExtension && this.rowDetailViewExtension.register) {
                    const rowSelectionExtension = this.getExtensionByName(ExtensionName.rowSelection);
                    this.rowDetailViewExtension.register(rowSelectionExtension === null || rowSelectionExtension === void 0 ? void 0 : rowSelectionExtension.instance);
                    const createdExtension = this.getCreatedExtensionByName(ExtensionName.rowDetailView); // get the plugin from when it was really created earlier
                    const instance = createdExtension && createdExtension.instance;
                    if (instance) {
                        this._extensionList[ExtensionName.rowDetailView] = { name: ExtensionName.rowDetailView, class: this.rowDetailViewExtension, instance };
                    }
                }
            }
            // Row Move Manager Plugin
            if (this.sharedService.gridOptions.enableRowMoveManager && this.rowMoveManagerExtension && this.rowMoveManagerExtension.register) {
                const rowSelectionExtension = this.getExtensionByName(ExtensionName.rowSelection);
                this.rowMoveManagerExtension.register(rowSelectionExtension === null || rowSelectionExtension === void 0 ? void 0 : rowSelectionExtension.instance);
                const createdExtension = this.getCreatedExtensionByName(ExtensionName.rowMoveManager); // get the instance from when it was really created earlier
                const instance = createdExtension && createdExtension.instance;
                if (instance) {
                    this._extensionList[ExtensionName.rowMoveManager] = { name: ExtensionName.rowMoveManager, class: this.rowMoveManagerExtension, instance };
                }
            }
        }
    }
    /**
     * Bind/Create certain plugins before the Grid creation to avoid having odd behaviors.
     * Mostly because the column definitions might change after the grid creation, so we want to make sure to add it before then
     * @param columnDefinitions
     * @param gridOptions
     */
    createExtensionsBeforeGridCreation(columnDefinitions, gridOptions) {
        var _a, _b, _c, _d, _e, _f;
        const featureWithColumnIndexPositions = [];
        // the following 3 features might have `columnIndexPosition` that we need to respect their column order, we will execute them by their sort order further down
        // we push them into a array and we'll process them by their position (if provided, else use same order that they were inserted)
        if (gridOptions.enableCheckboxSelector) {
            if (!this.getCreatedExtensionByName(ExtensionName.checkboxSelector)) {
                featureWithColumnIndexPositions.push({ name: ExtensionName.checkboxSelector, extension: this.checkboxSelectorExtension, columnIndexPosition: (_b = (_a = gridOptions === null || gridOptions === void 0 ? void 0 : gridOptions.checkboxSelector) === null || _a === void 0 ? void 0 : _a.columnIndexPosition) !== null && _b !== void 0 ? _b : featureWithColumnIndexPositions.length });
            }
        }
        if (gridOptions.enableRowMoveManager) {
            if (!this.getCreatedExtensionByName(ExtensionName.rowMoveManager)) {
                featureWithColumnIndexPositions.push({ name: ExtensionName.rowMoveManager, extension: this.rowMoveManagerExtension, columnIndexPosition: (_d = (_c = gridOptions === null || gridOptions === void 0 ? void 0 : gridOptions.rowMoveManager) === null || _c === void 0 ? void 0 : _c.columnIndexPosition) !== null && _d !== void 0 ? _d : featureWithColumnIndexPositions.length });
            }
        }
        if (gridOptions.enableRowDetailView) {
            if (!this.getCreatedExtensionByName(ExtensionName.rowDetailView)) {
                featureWithColumnIndexPositions.push({ name: ExtensionName.rowDetailView, extension: this.rowDetailViewExtension, columnIndexPosition: (_f = (_e = gridOptions === null || gridOptions === void 0 ? void 0 : gridOptions.rowDetailView) === null || _e === void 0 ? void 0 : _e.columnIndexPosition) !== null && _f !== void 0 ? _f : featureWithColumnIndexPositions.length });
            }
        }
        // since some features could have a `columnIndexPosition`, we need to make sure these indexes are respected in the column definitions
        this.createExtensionByTheirColumnIndex(featureWithColumnIndexPositions, columnDefinitions, gridOptions);
        if (gridOptions.enableDraggableGrouping) {
            if (!this.getCreatedExtensionByName(ExtensionName.draggableGrouping)) {
                const draggableInstance = this.draggableGroupingExtension.create(gridOptions);
                if (draggableInstance) {
                    gridOptions.enableColumnReorder = draggableInstance.getSetupColumnReorder;
                    this._extensionCreatedList[ExtensionName.draggableGrouping] = { name: ExtensionName.draggableGrouping, instance: draggableInstance, class: this.draggableGroupingExtension };
                }
            }
        }
    }
    /** Hide a column from the grid */
    hideColumn(column) {
        if (this.sharedService && this.sharedService.slickGrid && this.sharedService.slickGrid.getColumns && this.sharedService.slickGrid.setColumns) {
            const columnIndex = this.sharedService.slickGrid.getColumnIndex(column.id);
            this.sharedService.visibleColumns = this.removeColumnByIndex(this.sharedService.slickGrid.getColumns(), columnIndex);
            this.sharedService.slickGrid.setColumns(this.sharedService.visibleColumns);
        }
    }
    /** Refresh the dataset through the Backend Service */
    refreshBackendDataset(gridOptions) {
        this.gridMenuExtension.refreshBackendDataset(gridOptions);
    }
    /**
     * Remove a column from the grid by it's index in the grid
     * @param columns input
     * @param index
     */
    removeColumnByIndex(columns, index) {
        if (Array.isArray(columns)) {
            return columns.filter((_el, i) => index !== i);
        }
        return columns;
    }
    /** Translate the Cell Menu titles, we need to loop through all column definition to re-translate them */
    translateCellMenu() {
        if (this.cellMenuExtension && this.cellMenuExtension.translateCellMenu) {
            this.cellMenuExtension.translateCellMenu();
        }
    }
    /** Translate the Column Picker and it's last 2 checkboxes */
    translateColumnPicker() {
        if (this.columnPickerExtension && this.columnPickerExtension.translateColumnPicker) {
            this.columnPickerExtension.translateColumnPicker();
        }
    }
    /** Translate the Context Menu titles, we need to loop through all column definition to re-translate them */
    translateContextMenu() {
        if (this.contextMenuExtension && this.contextMenuExtension.translateContextMenu) {
            this.contextMenuExtension.translateContextMenu();
        }
    }
    /**
     * Translate the Header Menu titles, we need to loop through all column definition to re-translate them
     */
    translateGridMenu() {
        if (this.gridMenuExtension && this.gridMenuExtension.translateGridMenu) {
            this.gridMenuExtension.translateGridMenu();
        }
    }
    /**
     * Translate the Header Menu titles, we need to loop through all column definition to re-translate them
     */
    translateHeaderMenu() {
        if (this.headerMenuExtension && this.headerMenuExtension.translateHeaderMenu) {
            this.headerMenuExtension.translateHeaderMenu();
        }
    }
    /**
     * Translate manually the header titles.
     * We could optionally pass a locale (that will change currently loaded locale), else it will use current locale
     * @param locale to use
     * @param new column definitions (optional)
     */
    translateColumnHeaders(locale, newColumnDefinitions) {
        var _a;
        if (this.sharedService && this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translaterService || !this.translaterService.translate)) {
            throw new Error('[Slickgrid-Universal] requires a Translate Service to be installed and configured when the grid option "enableTranslate" is enabled.');
        }
        if (locale && ((_a = this.translaterService) === null || _a === void 0 ? void 0 : _a.use)) {
            this.translaterService.use(locale);
        }
        let columnDefinitions = newColumnDefinitions;
        if (!columnDefinitions) {
            columnDefinitions = this.sharedService.columnDefinitions;
        }
        this.translateItems(columnDefinitions, 'nameKey', 'name');
        this.translateItems(this.sharedService.allColumns, 'nameKey', 'name');
        // re-render the column headers
        this.renderColumnHeaders(columnDefinitions, Array.isArray(newColumnDefinitions));
        this.gridMenuExtension.translateGridMenu();
    }
    /**
     * Render (or re-render) the column headers from column definitions.
     * calling setColumns() will trigger a grid re-render
     */
    renderColumnHeaders(newColumnDefinitions, forceColumnDefinitionsOverwrite = false) {
        let collection = newColumnDefinitions;
        if (!collection) {
            collection = this.sharedService.columnDefinitions;
        }
        if (Array.isArray(collection) && this.sharedService.slickGrid && this.sharedService.slickGrid.setColumns) {
            if (collection.length > this.sharedService.allColumns.length || forceColumnDefinitionsOverwrite) {
                this.sharedService.allColumns = collection;
            }
            this.sharedService.slickGrid.setColumns(collection);
        }
        // recreate the Column Picker when enabled
        if (this.sharedService.gridOptions.enableColumnPicker) {
            this.recreateExternalAddon(this.columnPickerExtension, ExtensionName.columnPicker);
        }
        // recreate the Grid Menu when enabled
        if (this.sharedService.gridOptions.enableGridMenu) {
            this.recreateExternalAddon(this.gridMenuExtension, ExtensionName.gridMenu);
        }
        // recreate the Header Menu when enabled
        if (this.sharedService.gridOptions.enableHeaderMenu) {
            this.recreateExternalAddon(this.headerMenuExtension, ExtensionName.headerMenu);
        }
    }
    //
    // protected functions
    // -------------------
    /**
     * Some extension (feature) have specific `columnIndexPosition` that the developer want to use, we need to make sure these indexes are respected in the column definitions in the order provided.
     * The following 3 features could have that optional `columnIndexPosition` and we need to respect their column order, we will first sort by their optional order and only after we will create them by their specific order.
     * We'll process them by their position (if provided, else use same order that they were inserted)
     * @param featureWithIndexPositions
     * @param columnDefinitions
     * @param gridOptions
     */
    createExtensionByTheirColumnIndex(featureWithIndexPositions, columnDefinitions, gridOptions) {
        // 1- first step is to sort them by their index position
        featureWithIndexPositions.sort((feat1, feat2) => feat1.columnIndexPosition - feat2.columnIndexPosition);
        // 2- second step, we can now proceed to create each extension/addon and that will position them accordingly in the column definitions list
        featureWithIndexPositions.forEach(feature => {
            const instance = feature.extension.create(columnDefinitions, gridOptions);
            if (instance) {
                this._extensionCreatedList[feature.name] = { name: feature.name, instance, class: feature.extension };
            }
        });
    }
    /**
     * Get an Extension that was created by calling its "create" method (there are only 3 extensions which uses this method)
     *  @param name
     */
    getCreatedExtensionByName(name) {
        if (this._extensionCreatedList && this._extensionCreatedList.hasOwnProperty(name)) {
            return this._extensionCreatedList[name];
        }
        return undefined;
    }
    /**
     * Dispose of previous extension/addon instance, then re-register it and don't forget to overwrite previous instance ref
     * @param externalExtension - extension instance
     * @param extensionName - extension name
     */
    recreateExternalAddon(externalExtension, extensionName) {
        externalExtension.dispose();
        const instance = externalExtension.register();
        const extension = this.getExtensionByName(extensionName);
        if (extension) {
            extension.instance = instance;
        }
    }
    /** Translate an array of items from an input key and assign translated value to the output key */
    translateItems(items, inputKey, outputKey) {
        var _a;
        if (this.sharedService.gridOptions && this.sharedService.gridOptions.enableTranslate && (!this.translaterService || !this.translaterService.translate)) {
            throw new Error('[Slickgrid-Universal] requires a Translate Service to be installed and configured when the grid option "enableTranslate" is enabled.');
        }
        if (Array.isArray(items)) {
            for (const item of items) {
                if (item[inputKey]) {
                    item[outputKey] = (_a = this.translaterService) === null || _a === void 0 ? void 0 : _a.translate(item[inputKey]);
                }
            }
        }
    }
}
//# sourceMappingURL=extension.service.js.map