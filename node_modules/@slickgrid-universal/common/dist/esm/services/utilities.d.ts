import { FieldType, OperatorString, OperatorType } from '../enums/index';
import { EventSubscription, GridOption } from '../interfaces/index';
import { Observable, RxJsFacade, Subject, Subscription } from './rxjsFacade';
/**
 * Add an item to an array only when the item does not exists, when the item is an object we will be using their "id" to compare
 * @param inputArray
 * @param inputItem
 * @param itemIdPropName
 */
export declare function addToArrayWhenNotExists<T = any>(inputArray: T[], inputItem: T, itemIdPropName?: string): void;
/**
 * Simple function to which will loop and create as demanded the number of white spaces,
 * this is used in the CSV export
 * @param {Number} nbSpaces - number of white spaces to create
 * @param {String} spaceChar - optionally provide character to use as a space (could be override to use &nbsp; in html)
 */
export declare function addWhiteSpaces(nbSpaces: number, spaceChar?: string): string;
/**
 * Remove a column from the grid by it's index in the grid
 * @param array input
 * @param index
 */
export declare function arrayRemoveItemByIndex<T>(array: T[], index: number): T[];
/**
 * Try casting an input of type Promise | Observable into a Promise type.
 * @param object which could be of type Promise or Observable
 * @param fromServiceName string representing the caller service name and will be used if we throw a casting problem error
 */
export declare function castObservableToPromise<T>(rxjs: RxJsFacade, input: Promise<T> | Observable<T> | Subject<T>, fromServiceName?: string): Promise<T>;
/**
 * Convert a flat array (with "parentId" references) into a hierarchical (tree) dataset structure (where children are array(s) inside their parent objects)
 * @param flatArray input array (flat dataset)
 * @param options you can provide the following tree data options (which are all prop names, except 1 boolean flag, to use or else use their defaults):: collapsedPropName, childrenPropName, parentPropName, identifierPropName and levelPropName and initiallyCollapsed (boolean)
 * @return roots - hierarchical (tree) data view array
 */
export declare function unflattenParentChildArrayToTree<P, T extends P & {
    [childrenPropName: string]: P[];
}>(flatArray: P[], options?: {
    childrenPropName?: string;
    collapsedPropName?: string;
    identifierPropName?: string;
    levelPropName?: string;
    parentPropName?: string;
    initiallyCollapsed?: boolean;
}): T[];
/**
 * Mutate the original array and add a treeLevel (defaults to `__treeLevel`) property on each item.
 * @param {Array<Object>} treeArray - hierarchical tree array
 * @param {Object} options - options containing info like children & treeLevel property names
 * @param {Number} [treeLevel] - current tree level
 */
export declare function addTreeLevelByMutation<T>(treeArray: T[], options: {
    childrenPropName: string;
    levelPropName: string;
}, treeLevel?: number): void;
/**
 * Convert a hierarchical (tree) array (with children) into a flat array structure array (where the children are pushed as next indexed item in the array)
 * @param {Array<Object>} treeArray - input hierarchical (tree) array
 * @param {Object} options - you can provide "childrenPropName" (defaults to "children")
 * @return {Array<Object>} output - Parent/Child array
 */
export declare function flattenToParentChildArray<T>(treeArray: T[], options?: {
    parentPropName?: string;
    childrenPropName?: string;
    hasChildrenPropName?: string;
    identifierPropName?: string;
    shouldAddTreeLevelNumber?: boolean;
    levelPropName?: string;
}): Omit<T, number | typeof Symbol.iterator | "toString" | "valueOf" | "toLocaleString" | "charAt" | "charCodeAt" | "concat" | "indexOf" | "lastIndexOf" | "localeCompare" | "match" | "replace" | "search" | "slice" | "split" | "substring" | "toLowerCase" | "toLocaleLowerCase" | "toUpperCase" | "toLocaleUpperCase" | "trim" | "length" | "substr" | "codePointAt" | "includes" | "endsWith" | "normalize" | "repeat" | "startsWith" | "anchor" | "big" | "blink" | "bold" | "fixed" | "fontcolor" | "fontsize" | "italics" | "link" | "small" | "strike" | "sub" | "sup" | "padStart" | "padEnd" | "trimLeft" | "trimRight" | "trimStart" | "trimEnd">[];
/**
 * Create an immutable clone of an array or object
 * (c) 2019 Chris Ferdinandi, MIT License, https://gomakethings.com
 * @param  {Array|Object} objectOrArray - the array or object to copy
 * @return {Array|Object} - the clone of the array or object
 */
export declare function deepCopy(objectOrArray: any | any[]): any | any[];
/**
 * Empty a DOM element by removing all of its DOM element children leaving with an empty element (basically an empty shell)
 * @return {object} element - updated element
 */
export declare function emptyElement<T extends Element = Element>(element?: T | null): T | undefined | null;
/**
 * Empty an object properties by looping through them all and deleting them
 * @param obj - input object
 */
export declare function emptyObject(obj: any): any;
/**
 * @deprecated use `findItemInTreeStructure()` instead. Find an item from a hierarchical (tree) view structure (a parent that can have children array which themseleves can children and so on)
 * @param treeArray
 * @param predicate
 * @param childrenPropertyName
 */
export declare function findItemInHierarchicalStructure<T = any>(treeArray: T[], predicate: (item: T) => boolean, childrenPropertyName: string): T | undefined;
/**
 * Find an item from a tree (hierarchical) view structure (a parent that can have children array which themseleves can children and so on)
 * @param {Array<Object>} treeArray - hierarchical tree dataset
 * @param {Function} predicate - search predicate to find the item in the hierarchical tree structure
 * @param {String} childrenPropertyName - children property name to use in the tree (defaults to "children")
 */
export declare function findItemInTreeStructure<T = any>(treeArray: T[], predicate: (item: T) => boolean, childrenPropertyName: string): T | undefined;
/**
 * HTML encode using jQuery with a <div>
 * Create a in-memory div, set it's inner text(which jQuery automatically encodes)
 * then grab the encoded contents back out.  The div never exists on the page.
 */
export declare function htmlEncode(inputValue: string): string;
/**
 * Decode text into html entity
 * @param string text: input text
 * @param string text: output text
 */
export declare function htmlEntityDecode(input: string): string;
/**
 * Encode string to html special char and add html space padding defined
 * @param {string} inputStr - input string
 * @param {number} paddingLength - padding to add
 */
export declare function htmlEncodedStringWithPadding(inputStr: string, paddingLength: number): string;
/**
 * Check if input value is a number, by default it won't be a strict checking
 * but optionally we could check for strict equality, for example in strict "3" will return False but without strict it will return True
 * @param value - input value of any type
 * @param strict - when using strict it also check for strict equality, for example in strict "3" will return but without strict it will return true
 */
export declare function isNumber(value: any, strict?: boolean): boolean;
/**
 * Take a number (or a string) and display it as a formatted decimal string with defined minimum and maximum decimals
 * @param input
 * @param minDecimal
 * @param maxDecimal
 * @param decimalSeparator
 * @param thousandSeparator
 */
export declare function decimalFormatted(input: number | string, minDecimal?: number, maxDecimal?: number, decimalSeparator?: '.' | ',', thousandSeparator?: ',' | '_' | '.' | ' ' | ''): string;
/**
 * Loop through all properties of an object and nullify any properties that are instanceof HTMLElement,
 * if we detect an array then use recursion to go inside it and apply same logic
 * @param obj - object containing 1 or more properties with DOM Elements
 */
export declare function destroyObjectDomElementProps(obj: any): void;
/**
 * Format a number following options passed as arguments (decimals, separator, ...)
 * @param input
 * @param minDecimal
 * @param maxDecimal
 * @param displayNegativeNumberWithParentheses
 * @param symbolPrefix
 * @param symbolSuffix
 * @param decimalSeparator
 * @param thousandSeparator
 */
export declare function formatNumber(input: number | string, minDecimal?: number, maxDecimal?: number, displayNegativeNumberWithParentheses?: boolean, symbolPrefix?: string, symbolSuffix?: string, decimalSeparator?: '.' | ',', thousandSeparator?: ',' | '_' | '.' | ' ' | ''): string;
/**
 * From a dot (.) notation path, find and return a property within an object given a path
 * @param object - object input
 * @param path - path of the complex object, string with dot (.) notation
 * @returns outputValue - the object property value found if any
 */
export declare function getDescendantProperty<T = any>(object: T, path: string | undefined): any;
/** Get I18N Translation Prefix, defaults to an empty string */
export declare function getTranslationPrefix(gridOptions?: GridOption): string;
/**
 * From a Date FieldType, return it's equivalent moment.js format
 * refer to moment.js for the format standard used: https://momentjs.com/docs/#/parsing/string-format/
 * @param fieldType
 */
export declare function mapMomentDateFormatWithFieldType(fieldType: typeof FieldType[keyof typeof FieldType]): string;
/**
 * From a Date FieldType, return it's equivalent Flatpickr format
 * refer to Flatpickr for the format standard used: https://chmln.github.io/flatpickr/formatting/#date-formatting-tokens
 * also note that they seem very similar to PHP format (except for am/pm): http://php.net/manual/en/function.date.php
 * @param fieldType
 */
export declare function mapFlatpickrDateFormatWithFieldType(fieldType: typeof FieldType[keyof typeof FieldType]): string;
/**
 * Mapper for query operators (ex.: <= is "le", > is "gt")
 * @param string operator
 * @returns string map
 */
export declare function mapOperatorType(operator: OperatorType | OperatorString): OperatorType;
/**
 * Find equivalent short designation of an Operator Type or Operator String.
 * When using a Compound Filter, we use the short designation and so we need the mapped value.
 * For example OperatorType.startsWith short designation is "a*", while OperatorType.greaterThanOrEqual is ">="
 */
export declare function mapOperatorToShorthandDesignation(operator: OperatorType | OperatorString): OperatorString;
/**
 * Mapper for query operator by a Filter Type
 * For example a multiple-select typically uses 'IN' operator
 * @param operator
 * @returns string map
 */
export declare function mapOperatorByFieldType(fieldType: typeof FieldType[keyof typeof FieldType]): OperatorType;
/**
 * Takes an object and allow to provide a property key to omit from the original object
 * @param {Object} obj - input object
 * @param {String} omitKey - object property key to omit
 * @returns {String} original object without the property that user wants to omit
 */
export declare function objectWithoutKey<T = any>(obj: T, omitKey: keyof T): T;
/** Parse any input (bool, number, string) and return a boolean or False when not possible */
export declare function parseBoolean(input: any): boolean;
/**
 * Parse a date passed as a string (Date only, without time) and return a Date object (if valid)
 * @param inputDateString
 * @returns string date formatted
 */
export declare function parseUtcDate(inputDateString: any, useUtc?: boolean): string;
/**
 * Sanitize, return only the text without HTML tags
 * @input htmlString
 * @return text
 */
export declare function sanitizeHtmlToText(htmlString: string): string;
/**
 * Sanitize possible dirty html string (remove any potential XSS code like scripts and others), we will use 2 possible sanitizer
 * 1. optional sanitizer method defined in the grid options
 * 2. DOMPurify sanitizer (defaults)
 * @param gridOptions: grid options
 * @param dirtyHtml: dirty html string
 * @param domPurifyOptions: optional DOMPurify options when using that sanitizer
 */
export declare function sanitizeTextByAvailableSanitizer(gridOptions: GridOption, dirtyHtml: string, domPurifyOptions?: DOMPurify.Config): string;
/** Set the object value of deeper node from a given dot (.) notation path (e.g.: "user.firstName") */
export declare function setDeepValue<T = any>(obj: T, path: string | string[], value: any): void;
/**
 * Format a number or a string into a string that is separated every thousand,
 * the default separator is a comma but user can optionally pass a different one
 * @param inputValue
 * @param separator default to comma ","
 * @returns string
 */
export declare function thousandSeparatorFormatted(inputValue: string | number | null, separator?: ',' | '_' | '.' | ' ' | ''): string | null;
/**
 * Title case (or capitalize) first char of a string, for example "hello world" will become "Hello world"
 * Change the string to be title case on the complete sentence (upper case first char of each word while changing everything else to lower case)
 * @param inputStr
 * @returns string
 */
export declare function titleCase(inputStr: string, caseEveryWords?: boolean): string;
/**
 * Converts a string to camel case (camelCase), for example "hello-world" (or "hellow world") will become "helloWorld"
 * @param inputStr the string to convert
 * @return the string in camel case
 */
export declare function toCamelCase(inputStr: string): string;
/**
 * Converts a string to kebab (hypen) case, for example "helloWorld" will become "hello-world"
 * @param str the string to convert
 * @return the string in kebab case
 */
export declare function toKebabCase(inputStr: string): string;
/**
 * Converts a camelCase or kebab-case string to a sentence case, for example "helloWorld" will become "Hello World" and "hello-world" will become "Hello world"
 * @param str the string to convert
 * @return the string in kebab case
 */
export declare function toSentenceCase(inputStr: string): string;
/**
 * Uses the logic function to find an item in an array or returns the default
 * value provided (empty object by default)
 * @param any[] array the array to filter
 * @param function logic the logic to find the item
 * @param any [defaultVal={}] the default value to return
 * @return object the found object or default value
 */
export declare function findOrDefault<T = any>(array: T[], logic: (item: T) => boolean, defaultVal?: {}): any;
/** Get HTML Element position offset (without jQuery) */
export declare function getHtmlElementOffset(element: HTMLElement): {
    top: number;
    left: number;
};
/**
 * Converts a string from camelCase to snake_case (underscore) case
 * @param str the string to convert
 * @return the string in kebab case
 */
export declare function toSnakeCase(inputStr: string): string;
/**
 * Unsubscribe all Subscriptions
 * It will return an empty array if it all went well
 * @param subscriptions
 */
export declare function unsubscribeAll(subscriptions: Array<EventSubscription | Subscription>): Array<EventSubscription | Subscription>;
/**
 * Takes an input array and makes sure the array has unique values by removing duplicates
 * @param array input with possible duplicates
 * @return array output without duplicates
 */
export declare function uniqueArray<T = any>(arr: T[]): T[];
/**
 * Takes an input array of objects and makes sure the array has unique object values by removing duplicates
 * it will loop through the array using a property name (or "id" when is not provided) to compare uniqueness
 * @param array input with possible duplicates
 * @param propertyName defaults to "id"
 * @return array output without duplicates
 */
export declare function uniqueObjectArray(arr: any[], propertyName?: string): any[];
